(= definitions* (table)
   signatures* (if (isa sig 'table)
                   sig
                   (table)))

(= warn-redef (make-dyn t))

(= safeset (annotate 'mac
             (fn (var val)
               `(do (when (and (bound ',var)
                               (warn-redef))
                      (disp "*** redefining " (stderr))
                      (disp ',var (stderr))
                      (disp #\newline (stderr)))
                  (assign ,var ,val)))))

(= def (annotate 'mac
                 (fn (name parms . body)
                   `(do (sref signatures* ',parms ',name)
                        (sref definitions* '(fn ,parms ,@body) ',name)
                        (safeset ,name (fn ,parms ,@body))))))

(= mac (annotate 'mac
                 (fn (name parms . body)
                   `(do (sref signatures* ',parms ',name)
                        (sref definitions* '(macro ,parms ,@body) ',name)
                        (safeset ,name
                                 (annotate 'mac (fn ,parms ,@body)))))))

(mac cl-binary (f)
  (let bname (sym:string "ar-" f 2)
    `($ (case-lambda
          ((x y) (,bname x y))
          (args (pairwise ,bname args))))))

#;(= <  cl-binary.< ;now done in ac.scm
   >  cl-binary.>
   is cl-binary.is)

;support df!func and df.func
(let quotify (fn (x) (if (and acons.x (is car.x 'quote))
                         x
                         `',x))
  (mac df (x) `(ppr:definitions* ,(quotify x)))
  (= sig (annotate 'mac (fn (x) `(signatures* ,(quotify x))))))

(= dumb-delay-procedure
   (fn (cell args)
     (if car.cell
         (apply car.cell args)
         (let (name arglist . body) cdr.cell
           (let u (eval `(fn ,arglist ,@body))
             (scar cell u)
             ($ (namespace-set-variable-value! (ac-global-name name) u))
             (apply u args))))))
(def dumb-delay-fn (name arglist body)
  (let cell (cons nil (cons name (cons arglist body)))
    (fn args (dumb-delay-procedure cell args))))

(mac delay-def (name arglist . body) ;doesn't capture lexenv...
  `(do (sref signatures* ',arglist ',name)
       (sref definitions* '(fn ,arglist ,@body) ',name)
       (safeset ,name (dumb-delay-fn ',name ',arglist ',body))))

(def wrn args
  (each x args (write x) (prn))
  car.args)

(mac awhile (test . body)
  `(whilet it ,test ,@body))

(= drain (annotate 'mac
                   (fn (expr (o eof nil))
                     (w/uniq (gacc gdone gres)
                       `(with (,gacc nil ,gdone nil)
                          (while (no ,gdone)
                            (let ,gres ,expr
                              (if (is ,gres ,eof)
                                  (= ,gdone t)
                                  (= ,gacc (cons ,gres ,gacc))))) ;push does atomic crap; a compiler could realize nothing else could modify a private var like that...
                          (rev ,gacc))))))

(def flat1 (xs)
  (let u nil
    (each x xs
      (each y x
        (push y u)))
    (nrev u)))

(def interleave xses
  (flat1 (apply map list xses)))

(def nrev (xs)
  (let u nil
    (whilet head xs
      (= xs cdr.xs)
      (scdr head u) ;scdr is faster than (= cdr.it u) for various reasons
      (= u head))
    u))  

(mac =s args
  `(do ,@(map [cons '= _] pair.args)))

(mac p= args ;not quite right, doesn't reach inside data structures right
  (withs (vars (map car pair.args)
          vals (map cadr pair.args)
          uniqs (map [uniq] vals))
    `(with ,(interleave uniqs vals)
       (= ,@(interleave vars uniqs)))))

;;doesn't handle this
;(def nrev2 (xs)
;  (let u nil
;    (while xs  ;no whilet
;      (p= xs     cdr.xs
;          cdr.xs u
;          u      xs))
;    u))

(mac macro (args . body)
  `(annotate 'mac (fn ,args ,@body)))

(= fast-for
   (macro (v init max . body)
     (w/uniq (loop gmax ginit)
       `((fn (,ginit ,gmax ,loop)
           (,loop ,loop ,ginit ,gmax))
         ,init
         (+ 1 ,max)
         (fn (,loop ,v ,gmax)
           (if ($.unsafe-fx< ,v ,gmax)
               (do ,@body
                   (,loop ,loop ($.unsafe-fx+ ,v 1) ,gmax))))))))
(= fast-for2
   (macro (v init max . body)
     (w/uniq (gfn gmax ginit)
       `(with (,ginit ,init ,gmax ,max)
          ((rfn ,gfn (,v)
             (if ($.unsafe-fx< ,v ,gmax)
                 (do ,@body
                     (,gfn ($.unsafe-fx+ ,v 1)))))
           ,ginit)))))


(= accum (macro (accfn . body)
           (w/uniq gacc
             `(withs (,gacc nil
                      ,accfn ;[push _ ,gacc])
                      [= ,gacc (cons _ ,gacc)])
                ,@body
                (nrev ,gacc))))
   for (macro (v init max . body) ;egad, horrible tricks prevent malloc'ing
         (w/uniq (loop gmax ginit)
           `((fn (,ginit ,gmax ,loop)
               (,loop ,loop ,ginit ,gmax))
             ,init
             (+ 1 ,max)
             (fn (,loop ,v ,gmax)
               (when (< ,v ,gmax) ;this is faster than "unless"
                 ,@body
                 (,loop ,loop (+ ,v 1) ,gmax))))))
   n-of (macro (n expr)
          (w/uniq ga
            `(let ,ga nil
               (repeat ,n
                 (= ,ga (cons ,expr ,ga))) ;push is somewhat expensive
               (nrev ,ga)))))

(= dedup2 (fn (xs)
  (let u (table)
    (accum a
      (each x xs
        (unless u.x
          set:u.x
          a.x))))))

(def accumulate (comb f xs init next done)
  ((afn (xs total)
     (if (done xs)
         total
         (self (next xs) (comb (f xs) total))))
   xs init))

(mac redef (name args . body)
  `(let orig ,name
     (= ,name (fn ,args ,@body)
        (sig ',name) ',args)))

(redef tuples (n xs)
  (nrev:accumulate cons [firstn n _] xs nil [nthcdr n _] no))


(def symb args
  (sym (string args)))
(def totext args
  (downcase:string args))

(= not no
   id idfn
   flatten flat
   1- [- _ 1]
   1+ [+ _ 1]
   dec 1-
   caddr car:cddr
   square [* _ _]
   char [coerce _ 'char]
   )

(def sumlist (f xs)
  (accumulate + f:car xs 0 cdr no))

(def divides (d n)
  (is 0 (mod n d)))


(mac xloop (binds . body)
  `((rfn next ,(map car pair.binds)
      ,@body)
    ,@(map cadr pair.binds)))

;in order to redefine rand, need big randoms
(let mzn 31
  (def large-random-2pow (bits)
    (xloop (n bits tt 0)
      (if (> n mzn)
          (next (- n 31) (+ (* tt (expt 2 mzn))
                            ($.random (expt 2 mzn))))
          (+ (* tt (expt 2 n))
             ($.random (expt 2 n)))))))

(def intsize (n) ;number of binary digits
  int-len.n)
(redef rand ((o a nil) (o b nil))
  (if no.a
      ($.random)
      b
      (+ a (rand (- b a -1)))
      (mod (large-random-2pow (+ 11 intsize.a)) a)))

(redef trunc (x (o d 1))
  (orig (/ x d)))

(redef log (x (o base 10))
  (/ (orig x) (orig base)))



(= even $.even?
   odd  $.odd?
   ;zero $.zero?
   )

(def fast-expt-* (a n one *)
  ((fn (f)
     (f f a n one))
   (fn (f a n tt)
     (if (is n 0)
         tt
         even.n
         (f f (* a a) (/ n 2) tt)
         (f f a dec.n (* a tt))))))
  ;(xloop (a a n n tt one)
  ;  (if (is n 0)
  ;      tt
  ;      even.n
  ;      (next (* a a) (/ n 2) tt)
  ;      (next a dec.n (* a tt)))))

(def mod-expt (a n m) ;still mallocs, dammit
  ((fn (f)
     (f f a n 1))
   (fn (f a n tt)
     (if (is n 0)
         tt
         even.n
         (f f (mod (* a a) m) (div n 2) tt)
         (f f a dec.n (mod (* a tt) m))))))
  ;(fast-expt-* a n 1 (fn (x y) (mod (* x y) m))))

(def big-rand (n)
  (if (is n 0)
      0
      (< n 2147483648)
      (rand n)
      (+ (big-rand (mod n 2147483647))
         (* 2147483647
            (big-rand (trunc n 2147483647))))))

#;(redef sum (f a b)
    (accumulate + f a 0 1+ [$.> _ b]))

#;(def product (f a b)
  (accumulate * f a 1 inc [> _ b]))

(def factorial (n)
  (product id 1 n))

(def partial (f x)
  (fn args (apply f x args)))

;(mapn f a b c d) = (mapn (fn (x) (mapn [f x _] c d)) a b)
(def mapn (f a b . xs)
  (if no.xs
      (map f (range a b))
      (mapn [apply mapn (partial f _)
                   xs]
            a b)))

(def choose (n k) ;support only integers
  (let u (min k (- n k))
    (if (< u 0)
        0
        (/ (product id (- n u -1) n)
           (factorial u)))))

(def num->digs (n (o base 10) (o size nil))
  (let u (accumulate cons [mod _ base] n nil [div _ base] [is _ 0])
    (if no.size
        u
        (join (n-of (- size len.u) 0)
              u))))

(def digs->num (digs (o base 10))
  (accumulate (fn (x tt) (+ x (* tt base))) car digs 0 cdr no))
(= div $.quotient)

(def sumdigs (n (o base 10))
  (accumulate + [mod _ base] n 0 [div _ base] [is _ 0]))


(def factor (n)
  ((afn (n sqrtn guess facts)
     (if (> guess sqrtn)
         (nrev (cons n facts))
         (is 0 (mod n guess))
         (let u (/ n guess)
           (self u (sqrt u) guess (cons guess facts)))
         (self n sqrtn (inc guess) facts)))
   abs.n (sqrt abs.n) 2 nil))

(def prsn args
  (apply prs args)
  (prn)
  last.args)


(mac delay (x)
  (w/uniq (ran result)
    `(with (,ran nil ,result nil)
       (fn ()
         (if ,ran
             ,result
             (do1 (= ,result ,x)
                  (= ,ran t)))))))
(def force (x)
  (x))

(mac s-cons (a b)
  `(cons ,a (delay ,b)))
(def s-car (x) (car x))
(def s-cdr (x) (force (cdr x)))

(def ints-from (n)
  (s-cons n (ints-from inc.n)))

(def s-range (a b)
  (if (> a b)
      nil
      (s-cons a (s-range (+ a 1) b))))

(def s-map1 (f stm)
  (and stm
       (s-cons (f s-car.stm)
               (s-map1 f s-cdr.stm))))

(def s-map (f . stms)
  (if (no:cdr stms)
      (s-map1 f car.stms)
      (some no stms)
      nil
      (s-cons (apply f (map s-car stms))
              (apply s-map f (map s-cdr stms)))))

(def s-keep (test stm)
  (and stm
       (if (test s-car.stm)
           (s-cons s-car.stm
                   (s-keep test s-cdr.stm))
           (s-keep test s-cdr.stm))))

(def s-ref (stm n)
  (if (is n 0)
      s-car.stm
      (s-ref s-cdr.stm dec.n)))

(mac s-pop (stm)
  `(do1 (s-car ,stm)
        (= ,stm (s-cdr ,stm))))

(def s-merge (< . stms)
  (xloop (u (sort (compare < s-car) stms))
    (and u
         (s-cons (s-car car.u)
                 (next (if (no:s-cdr car.u)
                           cdr.u
                           (insert-sorted (compare < s-car)
                                          (s-cdr car.u)
                                          cdr.u)))))))

(def s-intersection (a b)
  (if (is s-car.a s-car.b)
      (s-cons s-car.a
              (s-intersection s-cdr.a s-cdr.b))
      (< s-car.a s-car.b)
      (s-intersection s-cdr.a b)
      (s-intersection a s-cdr.b)))

(def list->stream (xs)
  (and xs
       (s-cons car.xs (list->stream cdr.xs))))

(def stream->list (stm)
  (let u nil
    (while stm
      (push s-pop.stm u))
    nrev.u))

(def s-firstn (n stm)
  (and (> n 0)
       (cons s-car.stm
             (s-firstn dec.n s-cdr.stm))))

(def s-dedup (stm (o last (uniq)))
  (and stm
       (if (isnt s-car.stm last)
           (s-cons s-car.stm
                   (s-dedup s-cdr.stm
                            s-car.stm))
           (s-dedup s-cdr.stm last))))

(def s-until (test stm)
  (and stm
       (~test s-car.stm)
       (s-cons s-car.stm
               (s-until test s-cdr.stm))))

(def sieve (stm)
  (s-cons s-car.stm
          (sieve (s-keep [~divides s-car.stm _]
                         s-cdr.stm))))
(def sieve2 (stm)
  (let u s-car.stm
    (s-cons u 
            (sieve2 (s-keep [~divides u _]
                            s-cdr.stm)))))

(= primes (sieve ints-from.2))

(def s-reduce (f stm (o default))
  (if (no stm)
      default
      (xloop (s stm v s-car.stm)
        (if no.s
            v
            (next s-cdr.s (f v s-car.s))))))

(def f-nargs (f n)
  (let args (n-of n (gensym))
    (eval `(fn ,args (f ,@args)))))

(mac as (type val)
  `(coerce ,val ',type))

(def explode (s)
  (map sym (as cons string.s)))

(def uppercase (x)
  (and x
       (all [<= #\A _ #\Z]
            (as cons (as string x)))))

(mac fors (vars a b . body)
  (if no.vars
      `(do ,@body)
      `(for ,car.vars ,a ,b
         (fors ,cdr.vars ,a ,b ,@body))))


(def date-days (n)
  (date (* n 86400)))
(def average args
  (trunc (apply + args)
         (len args)))
(def find-interval (test lo hi toosmall)
  (if (test lo)
      lo
      (is lo hi)
      nil
      (let u (average lo hi)
        (if (toosmall u)
            (find-interval test (inc u) hi toosmall)
            (find-interval test lo u toosmall)))))
(def date-bef (da db)
  (and da
       (with (a (car da) b (car db))
         (if (< a b)
             t
             (is a b)
             (date-bef (cdr da) (cdr db))
             nil))))
;(date-days 14484) --> 2009 8 28
(let todays-date 0
  (def date-from-today (n)
    (if (iso (date-days todays-date) (date))
        (date-days (+ n todays-date))
        (do (= todays-date
               (find-interval [iso (date-days _) (date)]
                              1
                              20000
                              [date-bef (date-days _) (date)]))
            (date-from-today n)))))
(def find-date (d)
  (find-interval [iso (date-days _) d]
                 1
                 20000
                 [date-bef (date-days _) d]))
(def date-diff (da db)
  (- (find-date da) (find-date db)))

(def sep-str (sep str)
  (if (is str "")
      nil
      (aif (pos sep str)
           (cons (cut str 0 it)
                 (sep-str sep (cut str (inc it))))
           (list str))))


#;(mac dbg (x) ;superseded
  `(do (prs ',x "is ")
       (prn ,x)))

(def unix-date ()
  (let u (pipe-from "date -v-9H");this will die outside DST
    (drain (read u))))

(def ach-date ()
  (let (day month date time ass year) (unix-date)
    `(,year
      ,(cadr:assoc month (tuples 2 '(Jan 1 Feb 2 Mar 3 Apr 4 May 5 Jun 6 Jul 7 Aug 8 Sep 9 Oct 10 Nov 11 Dec 12)))
      ,(cadr:assoc day (tuples 2 '(Sun 0 Mon 1 Tue 2 Wed 3 Thu 4 Fri 5 Sat 6)))
      ,@(map int (sep-str #\: (string time))))))


(mac between (var expr within . body)
  (w/uniq first
    `(let ,first t
       (each ,var ,expr
         (unless ,first ,within)
         (wipe ,first)
         ,@body))))

(def comparator (<)
  (fn (x y)
    (if (< x y)
        1
        (< y x)
        -1
        0)))

(redef before (x y)
  (let u (comparator before)
    (case (type x)
      cons (case (u (car x) (car y))
             -1 nil 1 t 0 (before (cdr x) (cdr y)))
      nil nil
      ;int (< x y)
      ;num (< x y)
      ;string (< x y)
      sym (and (isnt x y) (< x y))
      ;char (< x y)
      (< x y)
      )))
;fuck that ;fuck that

#;(redef before (x y)
  (case type.x
    cons (if (before car.x car.y)
             t
             (before car.y car.x)
             nil
             (before cdr.x cdr.y))
    sym (and (isnt x y) (< x y))
    (< x y)))
  

(def but-nth (n xs)
  (join (firstn n xs)
        (nthcdr (1+ n) xs)))

(def deep-rev (xs)
  (if (alist xs)
      (rev (map deep-rev xs))
      xs))

(def deep-map (f xs)
  (if (acons xs)
      (cons (deep-map f car.xs)
            (deep-map f cdr.xs))
      no.xs
      nil
      f.xs))


(def count-up (xs)
  (let u (table)
    (each x xs
      (++ (u x 0)))
    (sort (compare > cadr) (tablist u))))


(def all-combos* (xs)
  (if no.xs
      list.nil
      (let u all-combos*:cdr.xs
        (mappend (fn (x)
                   (map [cons x _] u))
                 car.xs))))
(def all-combos xses
  (all-combos* xses))

;(def all-choices* (f xs)
;  (if (no:cdr xs)
;      (map f car.xs)
;      (no:car xs)
;      nil
;      (join (all-choices* (fn args (apply f (caar xs) args))
;                         (cdr xs))
;            (all-choices* f (cons (cdar xs) (cdr xs))))))
(def all-choices* (f xs)
  (map [apply f _] all-combos*.xs))
(def all-choices (f . xses)
  (all-choices* f xses))

(def inv (a m)
  "modular inverse of a mod m"
;  (zap mod a m)
;  (if (is a 0) nil
;      (is a 1) 1
;      (aif (inv (mod (- m) a) a)
;           (/ (+ 1 (* it m)) a))))
  (let u (car:bezout a m)
    (if (is 1 (mod (* u a) m))
        u
        nil)))

(def bezout (a b);express (gcd a b) as ax+by; returns (list x y)
  ;New algorithm:
  ;Demonstration:
  ;46, 7.
  ;(mod 46 7) = 4
  ;4 = 1*46 - 6*7 --> (1 -6)
  ;3 = 7 - 4 = (0 1) - (1 -6) = (-1 7)
  ;1 = 4 - 3 = (1 -6) - (-1 7) = (2 -13)
  (xloop (a a x1 1 y1 0
          b b x2 0 y2 1)
    (if (is b 0)
        (list x1 y1)
        (with (q (div a b) r (mod a b))
          (next b x2 y2
                r (- x1 (* q x2)) (- y1 (* q y2)))))))

;return (list x y) where ax + by = z; (gcd a b) better divide z
(def bezout2 (a b z)
  (let (x y) (bezout a b)
    (withs (the-gcd (inc:mod (dec:* a x) b)
            xx (mod (* x (/ z the-gcd)) (/ b the-gcd))
            yy (/ (- z (* a xx)) b))
      (list xx yy))))

(def chr2 (a am b bm);chinese remainder theorem
  (if (is a b) ;a special case... nyeh.
      a
      (let (x y) (bezout2 am bm (- a b))
        (mod (+ a (* (- x) am)) (lcm am bm)))))

(def chr args
  (car:reduce (fn ((a am) (b bm))
            (list (chr2 a am b bm)
                  (lcm am bm)))
          (tuples 2 args)))

#;(def gcd2 (a b)
  (if (zero b)
      a
      (gcd2 b (mod a b))))
;let's handle rational numbers
;... negative? screw that
;(builtin gcd indeed returns positives)
(= int? ($:lambda (x) (if (integer? x) 't 'nil)))
(def gcd2 (a b)
  (if (and (int? a) (int? b))
      ($.gcd a b)
      (/ ($.gcd numer.a numer.b) ($.lcm denom.a denom.b))))

(def gcd args
  (reduce gcd2 args))
(def lcm2 (a b)
  (/ (* a b) (gcd2 a b)))
(def lcm args
  (reduce lcm2 args))

(def totient (n)
  (accumulate * 1+:-:/:car dedup:factor.n n cdr no))



(def arc-namespace ()
  (map [sym:cut string._ 1]
       (keep [is string._.0 #\_]
             ($.namespace-mapped-symbols))))

(def apropos-fn (x)
  (sort < (keep [findsubseq x string._] (arc-namespace))))

(mac aps (x) `(apropos-fn (string ',x)))

(def scheme-apropos (x)
  (sort < (keep [findsubseq x string._] ($.namespace-mapped-symbols))))
(mac saps (x)
  `(scheme-apropos (string ',x)))


(= home-dir ($.path->string ($.find-system-path 'home-dir))
   home (fn args (string home-dir args))
   orders-file (home "ORDERS")
   orders-input (home "ARC_INPUT"))
(unless bound!src-directory
  (= src-directory (let u ($.current-load-relative-directory)
                     (if ($.tnil u)
                         ($.path->string u)))))

(def run-cmds ((o file orders-input))
  (while t
    (until (and (file-exists file)
                (errsafe:readfile file))
      (sleep .01))
    (fromfile file
      (awhile (read)
        (pprn it)
        (prn:eval it)))
    (rmfile file)
    (prn "waiting for command")))

(mac set-orders args
  `(do (tofile orders-file
         (ppr '(do ,@args)))
       (ppr '(do ,@args))))



(def pprn (expr (o col 0) (o noindent nil))
  ppr.expr
  (prn)
  expr)



(mac w/defs (defs . body)
  `(with ,(flat1 (map [list car._ nil] (tuples 3 defs)))
     (= ,@(flat1 (map (fn ((name args body))
                        `(,name (rfn ,name ,args ,body)))
                      (tuples 3 defs))))
     ,@body))

(mac zaps (f . args)
  `(do ,@(map (fn (x)
                `(zap ,f ,x))
              args)))

(def append args
  (let (a . b) rev.args
    (xloop (b (map rev b) a a)
      (if no.b
          a
          (next cdr.b (nflip car.b a))))))

(def nflip (xs tt)
  (if no.xs
      tt
      (let u cdr.xs
        (scdr xs tt)
        (nflip u xs))))
;polynomials are of the form (a0 a1 a2 ... an) = a0 + a1x + a2x^2 + ... + anx^n
;scalars can be coerced from n -> (n). zero-deg. poly.

(def scale-poly (p n)
  (if (> n 0)
      (append (n-of n 0) p)
      (nthcdr n p)))

(def butlast (n (o xs nil))
  (if (no xs)
      (= xs n n 1))
  (if (isa xs 'string)
      (cut xs 0 (- len.xs n))
      (rev (nthcdr n rev.xs))))

(def scale-rev-poly (p n)
  (if (> n 0)
      (append p (n-of n 0))
      (butlast n p)))

(def map-more (f . xses)
  (let u (rem nil xses)
    (if (no u)
        nil
        (cons (apply f (map car u))
              (apply map-more f (map cdr u))))))

(def add-poly polys
  (apply map-more + polys))

(def mul-poly (a b)
  (and b
       (if (is car.b 0) ;lol hax (almost certainly worth it)
           (scale-poly (mul-poly a cdr.b) 1)
           (add-poly (map [* _ car.b] a)
                     (scale-poly (mul-poly a cdr.b)
                                 1)))))

(def degree (p)
  ;(- len.p 1)) ;NAWP
  (xloop (p p n 0 i 0)
    (if no.p
        n
        (is car.p 0)
        (next cdr.p n inc.i)
        (next cdr.p i inc.i))))

;(= x '(1 0 1) y '(1 1))

#;(delay-def q/r-poly (p1 p2)
  (with (dezero (afn (p)
                    (if (is car.p 0)
                        (self cdr.p)
                        p)))
    (with (a dezero:rev.p1 b dezero:rev.p2) ;derf ;no, derf
      (xloop (a a q nil)
        (let u (- degree.a degree.b)
          (if (< u 0)
              (list q rev.a)
              (next (dezero
                     (add-poly a
                               (mul-poly (scale-rev-poly b u)
                                         (list (/ car.a car.b -1)))))
                    (add-poly (scale-poly (list (/ car.a car.b))
                                          u)
                              q))))))))

(def rev-and-dezero (p)
  (xloop (p p xs nil last-head nil)
    (if no.p
        last-head
        (is car.p 0)
        (next cdr.p (cons 0 xs) last-head)
        (let u (cons car.p xs)
          (next cdr.p u u)))))

(def q/r-poly (x d)
  (with (xx rev-and-dezero.x dd rev-and-dezero.d)
    (if no.dd
        (err "Dividing by zero polynomial" x d)
        no:cdr.dd
        (list (nrev:map [/ _ car.dd] xx) nil)
        (< len.xx len.dd)
        (list (nrev:map [/ _ car.dd] xx) nil)
        (with (drest (if (is car.dd 1) cdr.dd (map [/ _ car.dd] cdr.dd)) quot nil)
          (xloop ()
            (with (u car.xx x cdr.xx)
              ;probably not worth testing for 0; also would make a thing inconv.
              (each d drest
                (scar x (- (car x) (* u d)))
                (= x cdr.x))
              (= quot (cons u quot))
              ;quot should not pick up leading zeros, 'cause xx lacks them
              (= xx cdr.xx)
              (if x
                  (next)
                  (list quot (nrev:mem [isnt _ 0] xx)))))))))

(let nerf (rfn next (xd xs)
            (when xs
              (scar xd (+ car.xd car.xs))
              (if no:cdr.xd
                  (scdr xd cdr.xs)
                  (next cdr.xd cdr.xs))))
  (def nadd-poly (xdest xsrc)
    (if no.xdest
        xsrc
        (do (nerf xdest xsrc)
          xdest))))

(def remainder-poly (p1 p2)
  (cadr (q/r-poly p1 p2)))

(def quotient-poly (p1 p2)
  (car (q/r-poly p1 p2)))

(def dezero (p)
  (xloop (p rev.p)
    (if (is car.p 0)
        (next cdr.p)
        nrev.p)))

(def gcd-poly (p1 p2)
  (if (all 0 p2)
      p1
      (gcd-poly p2 (dezero (remainder-poly p1 p2)))))

(def prnpoly (xs (o var "x"))
  (let first t
    (on a xs
      (pr:string (and (isnt a 0)
                      (string (if first (= first nil) " + ")
                        (and (or (is index 0) (isnt a 1)) a)
                        (and (isnt index 0) (list var (and (isnt index 1) `("^" ,index))))))))
    (prn)
    xs))


(def find-substrs (startst endst xt (o start 0))
  (aif (posmatch startst xt start) 
       (let git (posmatch endst xt (+ it len.startst))
         (and git
              (cons (cut xt it (+ git len.endst))
                    (find-substrs startst endst xt (+ git len.endst)))))))

(def get-all-text (inpt)
  (do1 (tostring (drain (awhen (readline inpt) (wrn it) t)))
       close.inpt))

(def deep-replace (old new xs)
  (deep-map [if (testify.old _)
                new
                _]
            xs))


;poker...
;card: e.g. '(7 c) = 7 of clubs
(= suits* '(c d h s)
   cards* (range 1 13)
   card cons
   rank car
   suit cdr
   hands* '(high-card pair two-pair 3-kind straight flush full-house 4-kind straight-flush))

;

(delay-def rank-hand (ph)
  ;returns (list hand-type high-card-stuff)
  (withs (ph (sort before ph)
             rank-profile (sort (compare > cadr) (count-up (map rank ph)))
             hand [pos _ hands*])
         (cons (pos (general-case (map cadr rank-profile) iso
                      '(4 1) '4-kind
                      '(3 2) 'full-house
                      '(3 1 1) '3-kind
                      '(2 2 1) '2-pair
                      '(2 1 1 1) 'pair
                      '(1 1 1 1 1)
                      (with (flush? (apply is (map suit ph))
                                    straight? (or (iso (map rank ph) '(1 10 11 12 13))
                                                  (is (rank car.ph) (- 4 (rank last.ph)))))
                        (if (and straight? flush) 'straight-flush
                            straight? 'straight
                            flush? 'flush
                            'high-card))
                      (err "That should be all possible things..."))
                    hands*)
               (map car rank-profile))))
(def better-hand (h1 h2)
  (before h2 h1))

;(= fh73 (tuples 2 '(7 c 7 h 7 d 3 h 3 d))
;   stf9 (genlist [list _ 'c] 5 9)
;   stf13 (randperm 


(= numer $.numerator
   denom $.denominator)

(def real-man-mod (a m)
  (/ (mod (* denom.m numer.a) (* numer.m denom.a))
     (* denom.a denom.m)))

(redef range (a (o b nil))
  (if no.b
      (= b a a 1))
  (nrev:accumulate cons id a nil (if (isa a 'int)
                                     1+
                                     inc)
                   (if (isa a 'int)
                       [$.> _ b]
                       [> _ b])))

(def subsets (xs)
  (if no.xs
      list.nil
      (let u (subsets cdr.xs)
        (join (map [cons car.xs _] u)
              u))))

(def eval-poly (xs x)
  (accumulate (fn (y tt) (+ y (* x tt)))
              car
              rev.xs
              0
              cdr
              no))


(def safe-headmatch (head xt (o start 0))
  (and (>= (- len.xt start) len.head)
       (headmatch head xt start)))

(def rev-string (st)
  (as string (rev (as cons st))))



(def new-filename ((o front "tmp") (o back ""))
  (let u (string front back)
    (while (or (file-exists u) (dir-exists u))
      (= u (string front (rand-string 8) back)))
    u))

;(def tmpfile ()
;  (new-filename "/tmp/arctmp"))

(def tmpfile ()
  (let u (string "/tmp/arctmp" (rand-string 10))
    (if (file-exists u)
        (tmpfile)
        u)))

(def system-w/stdin (str cmd)
  (let f (tmpfile)
    (w/outfile a f (disp str a))
    (after (system:string "cat " f " | " cmd)
           (system:string "rm -f " f))))


(def find-links (xt)
  (map (fn (x)
         (cut x 6 -1))
       (join (find-substrs "href=\"" "\"" xt)
             (find-substrs "HREF=\"" "\"" xt))))

(def linkify (link source-url)
  (if (safe-headmatch "http://" link)
      link
      (string (trim source-url 'end [isnt _ #\/]) link)))

(def desired (link site)
  (zap trim site 'end #\/)
  (safe-headmatch (trim site 'end #\/) link))

(def get-links (xt source site)
  (keep [desired _ site] (map [linkify _ source] find-links.xt)))

(delay-def site-suck (site (o links site));e.g. http://en.wikipedia.org/wiki/
  (with (visiteds nil file (new-filename:string:keep alphadig site)
                  separator (string (n-of 10 "\n"))
                  links (map [list _ 'GOD] links))
    (while links
      (let (link src) pop.links
        (unless (mem link visiteds)
          prn.link
          (push link visiteds)
          (let c dl.link
            (prn ellipsize.c)
            (w/appendfile meh file
              (disp (string "Link: " link "\nSource: " src "\n" c separator) meh))
            (zap join links (map [list _ link] (get-links c link site)))))))
    rev.visiteds))

(def all-perms (xs)
  (if no.xs
      list.nil
      (let u nil
        (on c xs
          (let h (all-perms (but-nth index xs))
            (zap [nconc2 (map [cons c _] h) _] u)))
        u)))

(def last-pair (xs)
  (if acons:cdr.xs
      last-pair:cdr.xs
      xs))

(delay-def nconc args ;only consing comes from arg list
  ((fn (next) (next next args))
   (fn (next args)
     (if no.args
         nil
         no:car.args
         (next next cdr.args)
         ((fn (next) (next next car.args last-pair:car.args cdr.args))
          (fn (next head tail args)
            (if no.args
                head
                (do (scdr tail car.args)
                    (next next head last-pair.tail cdr.args)))))))))

(def nconc2 (x y)
  (if no.x
      y
      (do (scdr last-pair.x y)
          x)))
            

(def display-html (xt)
  (let u (new-filename "tmp" ".html")
    (w/outfile meh u (disp xt meh))
    (system:string "open " u)
    (thread (sleep 30) rmfile.u (prsn "Deleting" u))))

(mac show-html args
  `(display-html (tostring ,@args)))

(def rationalize (x (o tolerance (/ x 100000)))
  (if (< x 0)
      (-:rationalize -.x tolerance)
      (> x 1)
      (+ floor.x (rationalize (- x floor.x) tolerance))
      x
      (with (lo (- x tolerance) hi (+ x tolerance))
        (xloop (n 0 d 1)
          (let u (/ n d)
            (if (<= lo u hi)
                u
                (> u hi)
                (next n inc.d)
                (next inc.n d)))))))
;OH MY GOD YOU CAN PROBABLY USE CONTINUED FRACTIONS
; SO MUCH BETTER

(def prsp (x)
  (pr x " ")
  x)

(def agm2 (x y (o dd 200) (o n 30))
  (let tpow (expt 10 dd)
    (xloop (x (* x tpow) y (* y tpow) i 0)
      (if (or (is i n) (is x y))
          (list x y i)
          (next (div (+ x y) 2)
                (isqrt:* x y)
                (+ i 1))))))

(def bigint->fracs (n step (o size (round log.n)))
  (xloop (n n size size fracs nil)
    (if (or (< size step) (and fracs (> (len:string:car fracs) step)))
        rev.fracs
        (let u ($.rationalize (/ (div n (expt 10 (- size step))) (expt 10 step))
                              (expt 10 (- 2 step)))
          prn.u
          (next (- n (floor:* u (expt 10 size)))
                (- size step)
                (cons u fracs))))))

;(thread:time:let u (withs (tp (expt 10 50) bn 5000 u (/ (cint-omega 3 (expt 10 bn)) (expt 10 bn))) (agm3c (+ 1 /.tp) (+ 1 (/ u tp)) (+ 1 (/ square.u tp)) 30 bn)) (prsn (quote steps) last.u) (= bigx car.u))
;(time:let u (withs (tp (expt 10 50) bn 2000 u (/ (cint-omega 3 (expt 10 bn)) (expt 10 bn)))
;                     (agm3c (- 1 /.tp) (- 1 (/ u tp)) (- 1 (/ square.u tp)) bn 30))
;                 (prsn 'steps last.u)
;                 (= bigx car.u))


(def agm (xs (o dd 200) (o times 60))
  (with (tpow (expt 10 dd) n len.xs)
    (xloop (xs (map [* _ tpow] xs) i 0)
      (if (is i times)
          (cons 'achtung (cons i xs))
          (apply is xs)
          (join xs list.i)
          (next (mapn [int-nthroot (div (reduce + (map-chooses * _ xs))
                                        (choose n _)) _]
                      1 n)
                (+ i 1))))))
  

(def agm5 (a b c d e (o dd 200) (o n 30))
  (let tpow (expt 10 dd)
    (xloop (a (* a tpow) b (* b tpow) c (* c tpow) d (* d tpow) e (* e tpow) i 0)
      (if (or (is i n) (is a b c d e))
          (list a b c d e i)
          (let xs (list a b c d e)
            (next (div (+ a b c d e) 5)
                  (isqrt:div (reduce + (map-chooses * 2 xs)) 10)
                  (int-nthroot (div (reduce + (map-chooses * 3 xs)) 10) 3)
                  (int-nthroot (div (reduce + (map-chooses * 4 xs)) 5) 4)
                  (int-nthroot (reduce * xs) 5)
                  (+ i 1)))))))

(def agm4 (a b c d (o dd 200) (o n 30))
  (let tpow (expt 10 dd)
    (xloop (a (* a tpow) b (* b tpow) c (* c tpow) d (* d tpow) i 0)
      (if (or (is i n) (is a b c d))
          (list a b c d i)
          (next (div (+ a b c d) 4)
                (isqrt:div (+ (* a b) (* a c) (* a d)
                              (* b c) (* b d) (* c d)) 6)
                (int-nthroot (div (+ (* a b c) (* a b d)
                                     (* a c d) (* b c d)) 4) 3)
                (isqrt:isqrt:* a b c d)
                (+ i 1))))))

(def agm4b (a b c d (o dd 200) (o n 30))
  (let tpow (expt 10 dd)
    (xloop (a (* a tpow) b (* b tpow) c (* c tpow) d (* d tpow) i 0)
      (if (or (is i n) (is a b c d))
          (list a b c d i)
          (next (div (+ a b c d) 4)
                (isqrt:div (reduce + (map-chooses * 2 (list a b c d))) 6)
                (int-nthroot (div (reduce + (map-chooses * 3 (list a b c d))) 4) 3)
                (isqrt:isqrt:* a b c d)
                (+ i 1))))))
                                  

;dd = decimal digits of accuracy
;n = number of steps to take before stopping. But if 
; everything is equal before we reach n, stop anyway.
; Turns out you never get close to 30.
(def agm3 (x y z (o dd 200) (o n 30))
  (let tpow (expt 10 dd)
    (xloop (x (* x tpow) y (* y tpow) z (* z tpow) i 0)
      (if (or (is i n) (is x y z))
          (list x y z i)
          (next (div (+ x y z) 3)
                (isqrt:div (+ (* x y) (* y z) (* z x)) 3)
                (int-nthroot (* x y z) 3)
                (+ i 1))))))

(= floor (fn (x)
           ($.inexact->exact
            (if ($.complex? x)
                ($.make-rectangular ($.floor ($.real-part x))
                                    ($.floor ($.imag-part x)))
                ($.floor x)))))
(= ceiling ($:lambda (x)
             (inexact->exact
              (if (complex? x)
                  (make-rectangular (ceiling (real-part x))
                                    (ceiling (imag-part x)))
                  (ceiling x)))))
(redef round (x)
  (if complex.x
      (make-rectangular (orig real-part.x)
                        (orig imag-part.x))
      orig.x))
(def hear (x) (prn "hear") x)
(def mech (x) (= meh x))

(def agm3c (x y z (o n 30) (o dd 200))
  (let tpow (expt 10 dd)
    (xloop (x (* x tpow) y (* y tpow) z (* z tpow) i 0)
      (prsn 'loop i)
      (withs (xs string.x ys string.y zs string.z ul (dec:min len.xs len.ys len.zs))
        (prsn 'same (find-int [or (> _ ul) (no:is xs._ ys._ zs._)])))
      (if (or (is i n) (is x y z))
          (list x y z i)
          (next (round:/ (+ x y z) 3)
                (cint-nthroot (floor:/ (+ (* x y) (* y z) (* z x)) 3) 2)
                (cint-nthroot (floor:* x y z) 3)
                (+ i 1))))))

;We want the nth root of a large complex integer.
;My method shall be to take arctangents and sines and cosines, using Taylor series.  
;The alternative is to use 1/n-angle formulas for sine and cosine, which
; would require getting approximate solutions to polynomials of degree n.
;Which I could do with moar binary search, but it would be somewhat horrible.

(def eval-taylor (x term done)
  (xloop (xpow 1 n 0 total 0)
    (if done.n
        total
        (next (* x xpow)
              (+ n 1)
              (+ total (* xpow term.n))))))

(def taylor-sin (x done)
  (eval-taylor x [/ (case (mod _ 4) 1 1 3 -1 0)
                    factorial._]
               done))

(def taylor-cos (x done)
  (eval-taylor x [/ (case (mod _ 4) 0 1 2 -1 0)
                    factorial._]
               done))

(def taylor-atan (x done)
  (eval-taylor x [case (mod _ 4) 1 /._ 3 (/ -._) 0]
               done))

(= real-part $.real-part imag-part $.imag-part
   make-rectangular $.make-rectangular
   complex $.complex?)

(def bigger (x)
  [> _ x])

;(def int-log (x base) ;hella slow with big numbers
;  (if (< base 2)
;      (err "ACHTUNG" 'int-log x base)
;      (xloop (x x n 0)
;        (if (< x base)
;            n
;            (next (/ x base) (+ n 1))))))
(def floor-log (x base)
  (integer-finverse [expt base _] x))
;Now to see if I can do better...
(def log-contfrac-stream (base x) ;this parameter order is an artifact of how I worked it out by hand
  (let n (integer-finverse [expt base _] x)
    (s-cons n (log-contfrac-stream (/ x (expt base n)) base))))
;ok, so... given 2^k ≤ x < 2^k+1, we want a guess at log_b x.
(def log-approx-stream (x base)
  (let u (log-contfrac-stream base x)
    (s-map [eval-contfrac:s-take _ u]
           ints-from.1)))
(def is-power-of-2 (x)
  (is 0 (bit-and x (- x 1))));lolololololz
;I'm going to arbitrarily say "arithmetic with fixnums up to 2^12 is fine".
(defmemo int-log-approxer (base)
  (if (< base 2)
      (err "Don't like logs of base less than 2") ;I can probably allow fractions...
      (is-power-of-2 base)
      (let n dec:int-len.base
        (fn (x) (div dec:int-len.x n)))
      (xloop (xs (log-approx-stream base 2))
        ;now these things alternate between an over and an underestimate,
        ;beginning with an underestimate. also, all are fracs > 1.
        (withs (under-n numer:s-car.xs
                under-d denom:s-car.xs
                over-n  numer:s-car:s-cdr.xs
                over-d  denom:s-car:s-cdr.xs)
          ;int-len yields 1+log_2. we divide by log_2(base).
          ;therefore we divide by n/d, or multiply by d/n.
          (if (< over-n 4096)
              next:s-cdr:s-cdr.xs
              (fn (x)
                (binary-search [<= (expt base _) x]
                               (floor-div (* dec:int-len.x over-d) over-n)
                               (ceiling-div (* int-len.x under-d) under-n))))))))
;YES, THIS IS INDEED HELLA MORE EFFICIENT
(def int-log (x base)
  int-log-approxer.base.x)


;Sum: from k=0 to infinity
; 1/16^k * (-2/8k+4 - 1/8k+5 - 1/8k+6 + 4/8k+1)
(def rational-tau (tol)
  (* 2 (accumulate + [* (expt 16 -._)
                        (+ (/ 4 (+ 1 (* 8 _)))
                           (/ -1 (+ (* 8 _) 6))
                           (/ -2 (+ (* 8 _) 4))
                           (/ -1 (+ (* 8 _) 5)))]
                   0 0
                   inc (bigger:+ 1 (log /.tol 16)))))

;this is so fucking accurate
(def int-tau (tpow)
  (* 2 (accumulate + [floor:* (div tpow (expt 16 _))
                        (+ (/ 4 (+ 1 (* 8 _)))
                           (/ -1 (+ (* 8 _) 6))
                           (/ -2 (+ (* 8 _) 4))
                           (/ -1 (+ (* 8 _) 5)))]
                   0 0
                   inc (bigger:+ 3 (log tpow 16)))))

;(def int-tau (tpow)
;  (round:* (rational-tau /.tpow) tpow))
  
;the integers we deal with are tpow * real number
;on 10^4000 spend about 4 x 1700 msec on this
(def int-taylor (x term done tpow)
  (round:xloop (xpow tpow n 0 total 0)
    (if done.n
        total
        (next (div (* xpow x) tpow)
              (+ n 1)
              (+ total (* xpow term.n))))))

;can deal with negs; returns [-90, 90] degrees
;dies if x, tpow within a factor of 2 of each other
;really just calcs arctan(a/b) for any a,b
;can take rational x
(def int-atan (x tpow)
  (if (< x 0)
      (-:int-atan -.x tpow)
      (> abs.x tpow)
      (round:- (div int-tau.tpow 4) ;atan(1/x)=90-atan(x)
               (int-atan (floor:/ square.tpow x) tpow))
      (isnt type.x 'int)
      (int-atan round.x tpow)
      (is x 0)
      0
      (int-taylor x [case (mod _ 4) 1 /._ 3 (/ -._) 0]
                  (bigger:int-log tpow (div tpow x))
                  tpow)))

(def int-cos (theta tpow)
  (int-taylor theta [/ (case (mod _ 4) 0 1 2 -1 0)
                       factorial._]
              (bigger:integer-finverse factorial tpow)
              tpow))
(def int-sin (theta tpow)
  (int-taylor theta [/ (case (mod _ 4) 1 1 3 -1 0)
                       factorial._]
              (bigger:integer-finverse factorial tpow)
              tpow))

(= counting (let n 0 [do (prn:++ n) _]))
(def int-nthroot (x n)
  (xloop (g (expt 2 (div int-len.x n)))
    (let u (div (+ (* dec.n g) (div x (expt g dec.n))) n)
      (if (< (abs:- u g) 2)
          (dec:find-int [> (expt _ n) x] dec.g)
          next.u))))

(def cint-nthroot (x n) ;(o SECRET-GUESS 0))
  (if (no:complex x)
      (integer-finverse [expt _ n] x)
  ;Polar-ify x
      (withs (a real-part.x b imag-part.x
                r (isqrt:+ square.a square.b)
                nr (int-nthroot r n)
                theta (int-atan (/ (* nr b) a) nr)
                ntheta (div theta n))
        (make-rectangular (int-cos ntheta nr)
                          (int-sin ntheta nr)))))

(def cint-omega (n tpow)
  (withs (extra (cint-nthroot tpow 4) tpow (* extra tpow))
    (floor:/ (make-rectangular (int-cos (div int-tau.tpow n) tpow)
                               (int-sin (div int-tau.tpow n) tpow))
           extra)))

(def facs (n (o term-padding))
  (case n 1 (if term-padding (pad "1" term-padding) "1")
    (tostring:between (p n) (sort (compare < car) (count-up:factor n)) (pr " * ")
        (let u (tostring (pr p)
                 (if (> n 1) (pr '^ n)))
          (pr:if term-padding
                 (pad u term-padding)
                 u)))))

(= int-len $.integer-length)

(def my-isqrt (n)
  (xloop (g (expt 2 (div int-len.n 2)))
         (let u (div (+ g (div n g)) 2)
           (if (< (abs:- u g) 2)
               (dec:find-int [> square._ n] dec.g)
               next.u))))


(= dec [- _ 1])

(= progn do
   incf ++
   decf --
   setf =)


;This works, but Euler's ridiculous pentagonal recurrence thing works better.
(defmemo part-min (n (o min 1))
  (if (is n 0)
      1
      (> min n)
      0
      (+ (part-min (- n min) min)
         (part-min n inc.min))))

;p(n) = p(n-1) + p(n-2) - p(n-5) - p(n-7) + p(n-12) + ...
;The numbers are pentagonal.  Ridiculous.
(with (pent-min [ceiling-div (- 1 (isqrt:+ 1 (* 24 _))) 6]
       pent-max [floor-div (+ 1 (isqrt:+ 1 (* 24 _))) 6])
  (defmemo partition (n)
    (if (is n 0)
        1
        (sum [if (is _ 0)
                 0
                 (* (expt -1 inc._)
                    (partition:- n pent._))]
             pent-min.n
             pent-max.n))))

(def inverse-pent (n)
  ;(ceiling:/ (- 1 (isqrt:+ 1 (* 24 n))) 6))
  (let u (integer-finverse pent n)
    (if (is pent.u n)
        u
        (let u (-:integer-finverse pent:- n)
          (if (is pent.u n)
              u
              nil)))))

;Arrays (pseudo)
(def aref (x . indices)
  (x (apply list indices)))

(defset aref (x . indices)
  (w/uniq (gx gi)
    (list `(,gx ,x ,gi (list ,@indices))
          `(,gx ,gi)
          `(fn (val) (= (,gx ,gi) val)))))

#;(def collect (xs)
    (with (u nil last (car xs) n 0)
      (each x xs
        (if (is x last)
            (incf n)
            (progn (push (list n last) u)
                   (setf n 1 last x))))
      (when last
        (push (list n last) u))
      (nrev u)))

(mac withr (binds . body)
  (with (vars (map car (tuples 2 binds)))
    `(with ,(mappend [list _ nil] vars)
       (= ,@binds)
       ,@body)))

;here binds is (name args body) repeating
;the strategy is to stuff the environment of the rfns
; as extra arguments to them
;... fuck, then I'd have to change the places where
; the fns are actually called... well, I suppose I could
; bind them to new fns which call the old ones with the
; extra arguments... neh, fuck that.
;(mac w/rfns (binds . body)
  

(def collect (xs)
  (withr (count (fn (xs last n tt)
                  (if (or no.xs (isnt car.xs last))
                      (collect xs (cons (list last n) tt))
                      (count cdr.xs last inc.n tt)))
          collect (fn (xs tt)
                    (if no.xs
                        nrev.tt
                        (count cdr.xs car.xs 1 tt))))
    (collect xs nil)))

(redef acons (x)
  ($.tnil ($.pair? x)))
  ;(xloop (xs cdr.xs last car.xs n 1 tt nil) ;irritating
  ;       (if no.xs
  ;           (nrev:cons (list last n) tt)
  ;           (is car.xs last)
  ;           (next cdr.xs last inc.n tt)
  ;           (next cdr.xs car.xs 1 (cons (list last n) tt))

(mac special-with (binds . body)
  (withs (vars (map car (tuples 2 binds))
               gvars (map [uniq] vars))
         `(with ,(mappend list gvars vars)
            (= ,@binds)
            (do1 (do ,@body)
                 (= ,@(mappend list vars gvars))))))


(def prime-array (n)
  (let u ($ (make-vector (+ n 1) #t))
    (for i 0 1
      ($ (vector-set! u i (not #t))))
    (for i 2 sqrt.n
      (when ($.vector-ref u i)
        (let ij square.i
          (until ($.> ij n)
            (($ vector-set!) u ij ($:not #t))
            (++ ij i)))))
    u))

(= vref $.vector-ref
   vset (fn (v i val)
          (($ vector-set!) v i val)
          val)
   make-vector $.make-vector)

(def prime-bytes (n)
  (let u ($.make-bytes (+ n 1) 1)
    (for i 0 1
      (($ bytes-set!) u i 0))
    (for i 2 sqrt.n
      (when (is 1 ($.bytes-ref u i))
        (let ij square.i
          (until ($.> ij n)
            (($ bytes-set!) u ij 0)
            (++ ij i)))))
    u))


(def fermat-prime (p (o times 20))
  (if (< p 3)
      (is p 2)
      (xloop (n times)
        (or (is n 0)
            (and (is 1 (mod-expt (rand 2 p) dec.p p))
                 (next:- n 1))))))


;Rationale: a^p-1 = 1 mod p. Repeatedly take a square root. If p prime,
; then all numbers have only two square roots, so sqrt(1) = ¬±1.
;So, if we take an arbitrary number and repeatedly square it, if 
; we at some point get 1, the number before it should be -1.
;Let d = p-1 with all factors of 2 removed. Repeatedly squaring a^d
; should give us 1 eventually. If we reach 1 before reaching -1, then
; we know p isn't prime. Also, if we reach a^p-1 (i.e. have squared
; it s times, where 2^s * d = p-1) before we reach 1, then p isn't prime.

;According to Wikipedia:
;if n < 1,373,653, it is enough to test a = 2 and 3;
;if n < 9,080,191, it is enough to test a = 31 and 73;
;if n < 4,759,123,141, it is enough to test a = 2, 7, and 61;
;if n < 2,152,302,898,747, it is enough to test a = 2, 3, 5, 7, and 11;
;if n < 3,474,749,660,383, it is enough to test a = 2, 3, 5, 7, 11, and 13;
;if n < 341,550,071,728,321, it is enough to test a = 2, 3, 5, 7, 11, 13, and 17.

;Time for me to verify that shit.
;might not work if n<3
(def miller-rabin-test (n a d s)
  (let ax (mod-expt a d n)
    (or (is ax 1)
        (xloop (ax ax r 0)
          (and (isnt r s)
               (or (is n (+ 1 ax))
                   (next (mod (* ax ax) n) (+ r 1))))))))


(= ash $.arithmetic-shift
   bit-xor $.bitwise-xor)
;Bit hack: If n = 100101000 (base 2)
;          then n-1 = 100100111
;          and (n-1 xor n) = 1111
;          so (int-len (n-1 xor n)) = 1 + power of 2 dividing n.
;Only exception to this appears to be n=0.  Even negative mothafuckas work.
;... this turns out not to help much. using Scheme 'even? and 'zero? in mod-expt helps much more.
(def miller-rabin-prime (p (o times 10))
  (withs (s (dec:int-len:bit-xor dec.p (- p 2))
          d (ash dec.p -.s))
    (xloop (n times)
      (or (is n 0)
          (and (miller-rabin-test p (rand 2 dec.p) d s)
               (next (- n 1)))))))


(def miller-rabin-using (p xs)
  (withs (s (dec:int-len:bit-xor dec.p (- p 2))
          d (ash dec.p -.s))
    (xloop (xs xs)
      (or no.xs
          (and (miller-rabin-test p car.xs d s)
               next:cdr.xs)))))


(def sumn (f a b)
  (accumulate + f a 0 1+ [> _ b]))
(def countn (f a b)
  (sumn [if f._ 1 0] a b))


;When 'prime is first called, create a byte-string for prime
; sieve up to 1 million. (Arbitrary. Note that size of racket runtime
; is maybe 18 MB.) Uses Miller-Rabin (with secret sauce for small numbers)
; for anything exceeding 1 million.

(let prime-fn nil
  (def prime (p)
    (if prime-fn
        prime-fn.p
        (let size 10000000 ;up to 10m now because of prime-bits
          (let pb #;(prime-bytes size) (prime-bits size)
            (with (primo1 (* 2 3 5 7 11)
                   primo2 (* 13 17 19))
              (let new-prime-fn (fn (p)
                   (if (< p size)
                       #;(is 1 ($.bytes-ref pb p)) (bit-ref pb p)
                       (or (isnt 1 (gcd2 p primo1)) (isnt 1 (gcd2 p primo2)))
                       nil
                       (< p 1373653)
                       (miller-rabin-using p '(2 3))
                       (< p 4759123141)
                       (miller-rabin-using p '(2 7 61))
                       (miller-rabin-prime p)))
                (= prime new-prime-fn
                   prime-fn new-prime-fn))
              prime.p))))))

;(= pf ($:lambda (c p) ;could be smarter about ass
;        (let ((f (Œª (x) (modulo (+ c (* x x)) p)))
;              (big (max 10 (quotient (integer-sqrt p) 30)))) ;want this to use x64 crap to be awesome but no
;          (let loop ((x 2) (y (f 2)) (tt 1) (n 0) (old-x 2) (old-y (f 2)))
;            (if (= n big)
;                (let ((u (gcd tt p)))
;                  (cond ((= u 1) (loop x y 1 0 x y))
;                        ((= u p) (let loop ((x old-x) (y old-y))
;                                   (let ((u (gcd (- x y) p)))
;                                     (cond ((= u 1) (loop (f x) (f (f y))))
;                                           ((= u p) 'nil)
;                                           (#t u)))))
;                        (#t u)))
;                (loop (f x) (f (f y))
;                      (modulo (* tt (- x y)) p)
;                      (+ n 1)
;                      old-x old-y))))))

;ach, looks like Gmail or something didn't understand lambda.
(= pf ($:λ (c p) ;could be smarter about ass, doing gcd's only periodically; but no, gcd is faster when mallocs dominate runtime.
        (let ((f (λ (x) (modulo (+ c (* x x)) p)))) ;want this to use x64 crap to be awesome but no
          (let loop ((x 2) (y (f 2)))
            (let ((u (gcd (- x y) p)))
              (cond ((= u 1) (loop (f x) (f (f y))))
                    ((= u p) 'nil)
                    (#t u)))))))



(def fffactor (n)
  (if (is n 1) nil
      (< n 0) (cons -1 fffactor:-.n)
      (is n 0) nil
      (xloop (n n xs nil g 2)
        (if prime.n
            (nrev:cons n xs)
            (aif (xloop (g g)
                   (if (divides g n)
                       g
                       (> g 800)
                       nil
                       (next (+ g 1))))
                 (next (/ n it) (cons it xs) it)
                 (sort <
                       (xloop (n n xs xs c 1)
                         (aif (pf c n)
                              (let u (/ n it)
                                ((if prime.u
                                     [cons u _]
                                     [next u _ 1])
                                 (if prime.it
                                     (cons it xs)
                                     (next it xs 1))))
                              ;(do (prsn "Achtung" c n)
                              (next n xs inc.c)))))))))

(def ffactor (n)
  (if (is n 1) nil
      (< n 0) (cons -1 ffactor:-.n)
      (xloop (n abs.n xs nil g 2)
        (if (or (is n 1) (prime n))
            (nrev:cons n xs)
            (let f (xloop (g g sq isqrt.n)
                     (if (divides g n)
                         g
                         (next (+ g 1) sq)))
              (next (div n f) (cons f xs) f))))))
(= factor fffactor)




(def factorization-vector (n)
  (let u (make-vector inc.n nil)
    (for i 2 n
      (unless (vref u i)
        (for j 1 (trunc n i)
          (vset u (* i j) (cons i (vref u j))))))
    u))



(= morse '((".-" "a") ("-..." "b") ("-.-." "c") ("-.." "d") ("." "e") ("..-." "f") ("--." "g") ("...." "h") (".." "i") (".---" "j") ("-.-" "k") (".-.." "l") ("--" "m") ("-." "n") ("---" "o") (".--." "p") ("--.-" "q") (".-." "r") ("..." "s") ("-" "t") ("..-" "u") ("...-" "v") (".--" "w") ("-..-" "x") ("-.--" "y") ("--.." "z") ("-----" "0") (".----" "1") ("..---" "2") ("...--" "3") ("....-" "4") ("....." "5") ("-...." "6") ("--..." "7") ("---.." "8") ("----." "9")))

(def integral (f a b (o n 100))
  (with (tt 0 dx (/ (- b a) n 1.))
    (repeat n (++ tt f.a) (++ a dx))
    (* dx tt)))

(def letterp (c) (or (<= #\A c #\Z) (<= #\a c #\z)))

(def caesar-shift (xt a (o b))
  (if no.b
      (caesar-shift xt 0 a)
      (let shf (apply -
                      (map [case type._
                             int _
                             (- (int:downcase (case type._
                                                char _ 
                                                string _.0
                                                sym (string._ 0)))
                                (int #\a))]
                           (list b a)))
        (map [caesar-shift1 _ shf] xt))))

(def caesar-shift1 (c n)
  (let n (if (isa n 'int) n (- int:downcase.n (int #\a)))
    (if letterp.c
        (let z (int (if uppercase.c #\A #\a))
          (char:+ z (mod (+ int.c n -.z) 26)))
        c)))

(def to-char (x)
  (case type.x
    char x
    sym string.x.0
    string x.0))


(def begin-decrypt (xt)
  (= alphabet "abcdefghijklmnopqrstuvwxyz"
     crypt-key (string:n-of 26 ".")
     original-text xt
     text upcase.xt
     keylist nil)
  (def show-text ()
    (no:prn:map [or (alref keylist _) _] text))
  (mac set-key c-ps
    `(map set-key1 ',(tuples 2 c-ps)))
  (def set-key1 ((c p))
    (zaps downcase:to-char c p)
    (= (crypt-key (pos c alphabet)) p)
    (push (list upcase.c p) keylist)
    (= text (map [if (is _ upcase.c) p _] text))
    (show-text))
  
  )



;(= is ($:case-lambda
;       ((x y) (ar-is2 x y))
;       (args (pairwise ar-is2 args))))
;(each x '(< > is)
;  (eval `(use-cl-ass ,x)))


(= alphabet "abcdefghijklmnopqrstuvwxyz")

(def file-extension (str)
  (aif (pos #\/ str)
       (file-extension:cut str inc.it)
       (pos #\. str)
       (let u (cut str inc.it)
         (or file-extension.u
             u))))

(def likely-src-files ()
  (cons ($.build-path src-directory "a")
        (rem (orf $.directory-exists?
                  [no:in (file-extension
                          ($.path->string _))
                         "arc" "scm" "ss" "rkt"])
             (map [$.build-path src-directory _]
                  ($.directory-list src-directory)))))

(def src-fn (sym (o strict t)
                   (o files (likely-src-files)))
    (with (n 0 m 0)
      (each file files
        (w/infile ach file
          (let found nil
            (whiler s (errsafe:read ach fail*) [is _ fail*]
              (when (errsafe:if strict
                                (and acons.s
                                     (or (and (in car.s 'def 'mac 'assign 'xdef 'redef 'define 'defmemo)
                                              (is cadr.s sym))
                                         (and (is car.s '=)
                                              (aand (pos sym cdr.s)
                                                    (is 0 (mod it 2))))
                                         (and (in car.s 'define)
                                              (acons cadr.s)
                                              (is (car cadr.s) sym))))
                                (errsafe:mem sym flat.s)) ;(type #t) -> error
                (unless found
                  set.found
                  ++.m
                  (prn "From: " file))
                ++.n
                pprn.s)))))
      (prn "Found " n " results in " m " different files.")
      (> n 0)))

(mac src (name (o strict t))
  `(src-fn ',name ',strict))

(def expand-macros (expr macs)
  (if (not alist.expr)
      expr
      (mem car.expr macs)
      (expand-macros macex1.expr macs)
      (map [expand-macros _ macs] expr)))




(def delta (xs) (map - cdr.xs xs))
(= e 2.718281828459045 pi 3.141592653589793 euler e)


(def escape (s (o test '(#\' #\\ #\, #\space #\- #\")))
  (let test (case type.test
              cons [mem _ test]
              char [is _ test]
              fn test)
    (tostring:each c s
      (when test.c
        (pr #\\))
      pr.c)))

(def chdir (s)
  ($.current-directory s))

(= cp1 nil cp2 nil cp3 nil)
(def cp ()
  (let u (readall:clipboard)
    (do1 (if (len> u 1)
             (do (prn "Multiple expressions cp'd")
                 (map eval u))
             (eval car.u))
         (= cp3 cp2 cp2 cp1 cp1 u))))

(def deepcopy (x)
  (case type.x
    cons (cons (deepcopy car.x)
               (deepcopy cdr.x))
    sym x
    int x
    num x
    string (let new (newstring (len x))
             (forlen i x
               (= (new i) (x i)))
             new)
    table  (let new (table)
             (each (k v) x 
               (= (new k) (deepcopy v)))
             new)
    (err "Unsupported")))

(def bernoulli (n)
  (sum (fn (k)
         (sum (fn (v)
                (* (expt -1 v) (choose k v) (expt v n) (/:+ k 1)))
              0 k))
       0 n))

(redef rev (s)
  (if (isa s 'string)
      rev-string.s
      orig.s))

(= sig!newstring '(n (o c #\nul)))

(def pad (x wanted-len (o side 'left) (o pad-char #\space))
  (zap string x)
  (let padding (newstring (- wanted-len len.x) pad-char)
    (case side
      left (string padding x)
      right (string x padding))))

(mac for- (var a b . body)
  (w/uniq (ga gb gf)
    `(with (,ga ,a ,gb ,b)
       ((rfn ,gf (,var)
          (unless (< ,var ,gb)
            ,@body
            (,gf (- ,var 1))))
        ,ga))))


(defmemo part-list (n k (o m n));k parts at most m
  (if (is n k 0)
      list.nil
      (in 0 n k m)
      nil
      (join (map [cons m _]
                 (part-list (- n m) (- k 1) m))
            (part-list n k (- m 1)))))

(def print-line (left right (o line-len 80))
  (prn left (newstring (- line-len len.left len.right) #\space) right))

(def insert-between (x xs)
  (if (no cdr.xs)
      xs
      (cons car.xs (cons x (insert-between x cdr.xs)))))

(def part->str (xs)
  (string:insert-between "+" xs))

(def part-pairs (n k)
  (if (is inc.n (* 2 k))
      (pairify:part-list n k)
      (all-choices list
                   (part-list n k)
                   (part-list n (- n k -1)))))
(def pairify (xs)
  (and xs
       (join (map [list car.xs _]
                  xs)
             (pairify cdr.xs))))

(def all-part-pairs (n)
  ;(join (apply join (mapn [part-pairs n _] 1 (trunc n 2)))
  ;      (and odd.n (apply join (pairify:part-pairs n (/ inc.n 2))))))
  (apply join (mapn [part-pairs n _] 1 (trunc inc.n 2))))

(def achtung (n (o line-len 80)) ;prints partition pairs
  (each (a b) all-part-pairs.n
    (print-line part->str.a part->str.b line-len)))



;verbose for speed
(def find-int (test (o n 1) (o max nil))
  (if max
      (xloop (n n)
        (if (> n max)
            nil
            test.n
            n
            (next:+ n 1)))
      (xloop (n n)
        (if test.n
            n
            (next:+ n 1)))))
(def digital (c) (<= #\0 c #\9))

(let eof (uniq)
  (= readall
     (fn (src)
       ((afn (i)
          (let x (read i eof)
            (if (is x eof)
                nil
                (cons x (self i)))))
        (if (isa src 'string) (instring src) src)))))

(defmemo mennen (n a)
  (if (< a 0) 0
      (is a 0) 1
      (is n 0) 0
      (+ (mennen n (- a 1))
         (mennen (- n 1) a)
         (-:mennen (- n 1) (- a n)))))

(def rl ()
  (load "a"))

(defmemo choose-poly (k)
  (if (is k 0)
      '(1)
      (mul-poly (list (/ (- 1 k) k) /.k)
                (choose-poly (- k 1)))))

(def guess-poly (xs)
  (trim-poly
   (gp xs 0)))

(def gp (xs (o k 0))
  (if no.xs
      '(0)
      (add-poly (mul-poly (list car.xs)
                          (choose-poly k))
                (gp delta.xs inc.k))))

(def trim-poly (xs)
  (if (is 0 last.xs)
      (trim-poly butlast.xs)
      xs))

(redef lines (xt)
  (tokens xt #\newline))


(def divisors (n)
  (if (is n 1)
      '(1)
      (sort < (all-choices* * (map (fn ((f n)) (mapn [expt f _] 0 n))
                                   (count-up:factor n))))))

(def number-of-divisors (n)
  (if (is n 1)
      1
      (reduce * (map inc:cadr (count-up:factor n)))))

;note that "memory" = $.current-memory-use
; and "current-gc-milliseconds", "current-process-milliseconds"
; were supplied in ac.scm

(= gc-msec      current-gc-milliseconds
   process-msec current-process-milliseconds)

(mac mem-use body
  (w/uniq x
    `(let ,x (memory)
       ,@body
       (- (memory) ,x))))
(mac gc-time body
  (w/uniq x
    `(let ,x (gc-msec)
       ,@body
       (- (gc-msec) ,x))))

(mac utime body
  (w/uniq (gtime grtime ggc gmem)
    `(with (,gtime (msec) ,grtime (process-msec) ,ggc (gc-msec) ,gmem (memory))
       (do1 (do ,@body)
            (prn "time: " (- (msec) ,gtime)
                 " cpu: " (- (process-msec) ,grtime)
                 " gc: " (- (gc-msec) ,ggc)
                 " mem: " (- (memory) ,gmem))))))
(= time utime)


(mac fromfile (f . body)
  (w/uniq gf
    `(w/infile ,gf ,f
       (w/stdin ,gf
         ,@body))))

(mac tofile (f . body)
  (w/uniq gf
    `(w/outfile ,gf ,f
       (w/stdout ,gf
         ,@body))))

(mac ontofile (f . body)
  (w/uniq gf
    `(w/appendfile ,gf ,f
       (w/stdout ,gf
         ,@body))))

;now this will cause some problems
($:require racket)
;specifically, the function signature of "open-output-file" is different:
;it uses #:keyword args rather than optionals

(= outfile
   ($:lambda (f . args)
             (open-output-file f
                               #:mode 'text
                               #:exists
                               (if (pair? args)
                                   (case (car args)
                                     ((append) 'append)
                                     ((truncate) 'truncate)
                                     ((update) 'update)
                                     ((can-update) 'can-update))
                                   'truncate))))

;(def generator (p) ;hella slow, sucks, see prim-root
;  (find-int (fn (g) (is dec.p (len:dedup:mapn [mod-expt g _ p] 0 dec.p)))
;            1))
;(def generators (p)
;  (keep (fn (g) (is dec.p (len:dedup:mapn [mod-expt g _ p] 0 dec.p)))
;        (range 1 dec.p)))
(= million 1000000
   tau (* 2 pi))

(def AF-ify ()
  (pbcopy:tostring (map [prn "  " _] (lines:pbpaste))))

(def flip (xs tt)
  (if no.xs
      tt
      (flip cdr.xs (cons car.xs tt))))

(def merge-sorteds (< x y)
  ((afn (x y tt)
     (if no.x
         (flip tt y)
         no.y
         (flip tt x)
         (< car.y car.x)
         (self x cdr.y (cons car.y tt))
         (self cdr.x y (cons car.x tt))))
   x y nil))

(def my-sort (< xs)
  ((afn (xses tt)
     (if no.xses
         (self rev.tt nil)
         (no:cdr xses)
         (if no.tt
             car.xses
             (self (rev:cons car.xses tt)
                   nil))
         (self cddr.xses
               (cons (merge-sorteds < car.xses cadr.xses)
                     tt))))
   (map list xs)
   nil))

(= vref $.vector-ref)
(def setv (vec ind val)
  (($ vector-set!) vec ind val)
  val)
(= vec $.vector
   make-vec $.make-vector
   vlen $.vector-length)

(def swapv (v i j)
  (let tmp (vref v i)
    (setv v i (vref v j))
    (setv v j tmp)))

(def randperm (xs)
  (let v ($.list->vector ($.ac-denil xs))
    (let u len.xs
      (for i 0 dec.u
        (swapv v i (rand i dec.u)))
      ($.vector->list v))))

(def map-subperms (f n xs)
  (if (is n 1)
      (map f xs)
      (apply join
             (mapn [let u xs._
                     (map-subperms (fn args (apply f u args))
                                  dec.n
                                  (but-nth _ xs))]
                   0 (dec len.xs)))))

(def map-chooses (f n xs)
  (if no.xs
      nil
      (is n 1)
      (map f xs)
      (join (map-chooses (fn args (apply f car.xs args))
                         dec.n
                         cdr.xs)
            (map-chooses f n cdr.xs))))

(def take (n xs)
  (firstn n xs))

(def cuberoot (x)
  (if (and ($.real? x) (< x 0))
      (-:expt -.x 1/3)
      (expt x 1/3)))

(def unix (s)
  (fn args (system:string:intersperse " " (cons s args))))
(= gc $.collect-garbage)

(= regular-alphabet (string #\newline (mapn char 32 126)))

;Prints out longest words typed with left hand, right hand, and alternating hands, given left hand side.
(def kbd-demo (lhs (o n 5))
  (let rhs (rem [pos _ lhs] alphabet)
    (with (rh (string "[" rhs "]")
              lh (string "[" lhs "]"))
      (let words (fn (rx)
                   (sort (compare > len:string)
                         (readall:tostring:system:string "egrep -i '" rx "' /usr/share/dict/words")))
        (let show [each x _ (prsn x (len:string x))]
          prn!left
          (show:take n (words:string "^" lh "*$"))
          prn!right
          (show:take n (words:string "^" rh "*$"))
          prn!alt
          (show:take n (words:string "^" lh "?(" rh lh ")*" rh "?$")))))))

(def pr-same xses
  (let u (apply map (fn args (apply max (map len:string args))) xses)
    (no:map (fn (xs)
              (map (fn (a l) (pr (pad a l) " ")) xs u)
              (prn))
            xses)))

(def naive-contfrac (x (o n 12))
  (and (> n 0)
       (if (isa x 'int)
           list.x
           (let u floor.x
             (cons u (naive-contfrac (/:- x u) dec.n))))))

;We deal with [root(n)+c]/d. Subtract floor and invert, and multiply
; by conjugate, and we will get another number of form [root(n)+c]/d.
;This can be verified by induction.
;Eventually, we should get a repeated [root(n)+c]/d.

(= isqrt $.integer-sqrt)
(def sqrt-contfrac (n)
  (if (is (square isqrt.n) n)
      `((,isqrt.n) (0))
      (let u (table)
        (xloop (i 0 c 0 d 1 xs nil)
          (aif (u (list c d))
               (split nrev.xs it)
               (let e (floor:/ (+ isqrt.n c) d)
                 (= (u (list c d)) i)
                 (next inc.i
                       (- (* d e) c)
                       (+ (/ (- n square.c) d) (* 2 c e) (* -1 d e e))
                       (cons e xs))))))))
(def eval-contfrac (xs (o n +inf.0))
  (if (or no:cdr.xs (< n 2))
      car.xs
      (+ car.xs (/:eval-contfrac cdr.xs (- n 1)))))
(= inex $.exact->inexact)



(= float-accuracy 300) ;

(def integer-finverse (f val)
  ;f better be increasing
  ;returns floor of x s.t. f(x) = val
  (if (> f.1 val)
      0
      (> f.2 val)
      1
      (xloop (n 1)
        (if (is f.n val)
            n
            (> f.n val)
            (xloop (n (/ n 2) d (/ n 4))
              (if (<= d 1)
                  (if (<= (f inc.n) val)
                      inc.n
                      n)
                  (<= (f:+ n d) val)
                  (next (+ n d) (/ d 2))
                  (next n (/ d 2))))
            (next (* n 2))))))

(def icuberoot (n)
  (integer-finverse [expt _ 3] n))

(def catalan (n) (/ (choose (* 2 n) n) inc.n))

(= ln $.log)



(defmemo super-catalan (n (o k 0))
  (if (is n 0) 1
      (+ (super-catalan dec.n inc.k)
         (* 2 (sum [super-catalan dec.n _] 0 k)))))


(def grid (xses (o strict nil)
                (o align-left [in type._ 'num 'int])) ;dense lines of code for brevity ;yeah rt
  (let lens (mapn [best > (map (fn (xs) (len:string:car:nthcdr _ xs)) xses)]
                 0 (dec:best > (map len xses)))
    (when strict (let u (best > lens) (= lens (n-of len.lens u))))
    (each xs xses (apply prsn (map (fn (x l)
                                     (pad x l (if align-left.x 'left 'right)))
                                   xs lens)))))

(def drop (n xs)
  (nthcdr n xs))

;O(log n) methods for Fibonacci.
;Method 1: Repeated squaring to evaluate
; [(1+root5)^n - (1-root5)^n] / [root5 * 2^n]
;Method 2: Repeated squaring to evaluate
; ((1 1) (1 0))^n * (1 0) and take the bottom elt.
(def fib-sqrt (n)
  (/ (- (cadr:meh-pow 1 1 5 n)
        (cadr:meh-pow 1 -1 5 n))
     (expt 2 n)))
;[a+b*root(r)]^n
;[a+brootc][d+erootc] = (ad+bce)+(ae+bd)rootc
(def meh-pow (a b r n)
  (xloop (a a b b ta 1 tb 0 n n)
    (if (is n 0)
        (list ta tb)
        (even n)
        (next (+ (* a a) (* b b r))
              (* 2 a b)
              ta tb (/ n 2))
        (next a b
              (+ (* a ta) (* b tb r))
              (+ (* a tb) (* b ta))
              (- n 1)))))

;(a b) ^ 2  ([aa+bc] [ab+bd])
;(c d)  --> ([ac+cd] [bc+dd])
(def fib-matr (n)
  (xloop (a 1 b 1 c 1 d 0 u 1 v 0 n n)
    (if (is n 0)
        v
        (even n)
        (next (+ (* a a) (* b c))
              (+ (* a b) (* b d))
              (+ (* a c) (* c d))
              (+ (* b c) (* d d))
              u v (/ n 2))
        (next a b c d
              (+ (* a u) (* b v))
              (+ (* c u) (* d v))
              (- n 1)))))

(def fib-matr2 (n)
  (xloop (b 1 d 0 u 1 v 0 n n)
    (if (is n 0) v
        (even n)
        (next (* b (+ b d d))
              (+ (* b b) (* d d))
              u v (/ n 2))
        (next b d
              (+ (* u (+ b d))
                 (* v b))
              (+ (* u b) (* v d))
              (- n 1)))))

(def fib (n)
  (fib-matr2 n))

(def fib-mod (n m)
  (xloop (b 1 d 0 u 1 v 0 n n)
    (if (is n 0) v
        (even n)
        (next (mod (* b (+ b d d)) m)
              (mod (+ (* b b) (* d d)) m)
              u v (/ n 2))
        (next b d
              (mod (+ (* u (+ b d)) (* v b)) m)
              (mod (+ (* u b) (* v d)) m)
              (- n 1)))))
;; (let m 1234567891011
;;   (with (a (fib-mod (expt 10 14) m) b (fib-mod (inc:expt 10 14) m))
;;     (def mfib (n)
;;       (fb (- n (expt 10 14))))
;;     (defmemo fb (n)
;;       (if (is n 0) a (is n 1) b
;;           (mod (+ (fb:- n 1) (fb:- n 2)) m)))))

(= fib-matrix '((1 1) (1 0)))

;(= ceiling $.ceiling)
 
(def sys args
  (tostring:system:string args))

(def pent (n)
  (/ (* n (- (* 3 n) 1)) 2))

(def mat-add (a b)
  (map (fn (x y) (map + x y)) a b))
(def mat-trans (x)
  (apply map list x))
(def mat-mul (a b)
  (let u mat-trans.b
    (map (fn (xa)
           (map (fn (xb)
                  (reduce + (map * xa xb)))
                u))
         a)))
(def mat-id (n)
  (mapn (fn (x y) (if (is x y) 1 0)) 1 n 1 n))
;(def mat-dims (x)
;  (list len.x len:car.x))

(def mat-det (x) ;hellza slow; O(n!), feels good man
  (if no:cdr.x
      caar.x
      (sum (fn (n) (* x.0.n (expt -1 n)
                      (mat-det:map [but-nth n _] cdr.x)))
           0 dec:len.x)))

(def matrix (row col)
  (n-of row (n-of col 0)))

(def lu-decomp (M) ;oh fuck this screws up if ass happens
  (withs (n len.M
          L (matrix n n)
          U (matrix n n)
          x (- n 1))
    (for i 0 x (= L.i.i 1))
    (for k 0 x
      (for i k x (= U.k.i (/ (- M.k.i (sum [* L.k._ U._.i] 0 dec.k)) L.k.k)))
      (for i inc.k x (= L.i.k (/ (- M.i.k (sum [* L.i._ U._.k] 0 dec.k)) U.k.k))))
    (cons L U)))

(def diag-product (M)
  (let n len.M
    (accumulate * [M._ _] 0 1 inc [is _ n])))

(def mat-det2 (M)
  (let (L . U) lu-decomp.M
    (* diag-product.L diag-product.U)))


(def mat-expt (x n)
  (fast-expt-* x n mat-id:len.x mat-mul))

(def mod-ify (m f)
  (fn (x y)
    (mod (f x y) m)))
(def mat-add-mod (a b m)
  (map (fn (x y) (map (mod-ify m +) x y)) a b))
(def mat-mul-mod (a b m)
  (let u mat-trans.b
    (map (fn (xa)
           (map (fn (xb)
                  (reduce (mod-ify m +) (map (mod-ify m *) xa xb)))
                u))
         a)))

;superseded later down for incredible speed
;(def mat-mod-expt (x n m)
;  (fast-expt-* x n mat-id:len.x
;               (fn (x y) (mat-mul-mod x y m))))

(def curl args
  (apply sys "curl -s " args))
(= QC "http://questionablecontent.net/")

(def symbol-value (x)
  ($.namespace-variable-value $.ac-global-name.x))

(= symbol-function symbol-value)

(defset symbol-value (x)
  (w/uniq g
    (list `(,g ,x)
          `(symbol-value ,g)
          `(fn (val) (($ namespace-set-variable-value!)
                      ($.ac-global-name ,g)
                      val)
             val))))

(defset symbol-function (x)
  (w/uniq g
    (list `(,g ,x)
          `(symbol-function ,g)
          `(fn (val) (($ namespace-set-variable-value!)
                      ($.ac-global-name ,g)
                      val)
             val))))


; (prepare-cxr a d d) -> caddr
(mac prepare-cxr args
  `(do (prepare-cxr-func ,@args)
       (prepare-cxr-setter ,@args)))

(mac prepare-cxr-func args
  (withs (crify [symb 'c _ 'r]
          name  (crify args))
    `(def ,name (x)
       ,(xloop (rx rev.args xs 'x)
          (if no.rx
              xs
              (next cdr.rx (list (crify car.rx) xs)))))))

(mac prepare-cxr-setter args
  (withs (crify [symb 'c _ 'r]
          name  (crify args))
    `(defset ,name (x)
      (w/uniq g
        (list (list g x)
              `(,',name ,g)
              `(fn (val)
                 (,',(symb 'sc car.args 'r)
                  ;Ridiculous quasiquoting stuff
                  ,,(xloop (rx (rev cdr.args) xs ',g)
                      (if no.rx
                          (list 'quasiquote xs)
                          (next cdr.rx (list (crify car.rx) xs))))
                  val)))))))


; (prepare-cxrs 2) -> caar, cadr, cdar, cddr
(mac prepare-cxrs (n)
  ;Now we really don't want to (def car (x) (car x)),
  ; which makes the entire Arc REPL die.  Likewise cdr.
  ;So I hard-code the n=1 case.
  (case n
    1 '(do (prepare-cxr-setter a)
           (prepare-cxr-setter d))
    `(do ,@(map (fn (xs) `(prepare-cxr ,@xs))
              (map [map [case _
                          0 'a
                          1 'd]
                        (num->digs _ 2 n)]
                   (range 0 (- (expt 2 n) 1)))))))

(mac w/stderr (x . body)
  `(call-w/stderr ,x (fn () ,@body)))
(w/outstring i\'m-not-listening
  (w/stderr i\'m-not-listening
    (prepare-cxrs 2)
    (prepare-cxrs 3)))
(mac to-stderr body
  `(w/stdout (stderr) ,@body))

(mac muffling-stderr body
  (w/uniq i\'m-not-listening
    `(w/outstring ,i\'m-not-listening
       (w/stderr ,i\'m-not-listening
         ,@body))))
(mac stfu body
  (w/uniq dev-null
    `(w/outstring ,dev-null
       (w/stdout ,dev-null
         (w/stderr ,dev-null
           ,@body)))))

;OMG terminal colors
;http://www.frexx.de/xterm-256-notes/
;echo -e "\033[47m\033[1;31mBright red on white.\033[0m"

(def str-colored (str (o color 'red) (o bold t))
  (string "\033["
          (if bold 1 0)
          ";"
          (case color
            black 30
            red 31
            green 32
            yellow 33
            blue 34
            magenta 35
            cyan 36
            white 37)
          "m"
          str
          "\033[m"))

(def pr-colored (str (o color 'red) (o bold t))
  (pr:str-colored str color bold))

(= dvorak-keyboard "`1234567890[]',.pyfgcrl/=\\aoeuidhtns-;qjkxbmwvz"
   qwerty-keyboard "`1234567890-=qwertyuiop[]\\asdfghjkl;'zxcvbnm,./"
   keyboard dvorak-keyboard
   shift-keyboard "~!@#$%^&*(){}\"<>PYFGCRL?+|AOEUIDHTNS_:QJKXBMWVZ"
   option-keyboard "`¬°‚Ñ¢¬£¬¢‚àû¬ß¬∂‚Ä¢¬™¬∫‚Äú‚Äò√¶‚â§‚â•œÄ¬•∆í¬©√ß¬Æ¬¨√∑‚â†¬´√•√∏¬¥¬®ÀÜ‚àÇÀô‚Ä†Àú√ü‚Äì‚Ä¶≈ì‚àÜÀö‚âà‚à´¬µ‚àë‚àöŒ©"
   option-shift-keyboard "`‚ÅÑ‚Ç¨‚Äπ‚Ä∫Ô¨ÅÔ¨Ç‚Ä°¬∞¬∑‚Äö‚Äù‚Äô√Ü¬ØÀò‚àè√Å√èÀù√á‚Ä∞√í¬ø¬±¬ª√Ö√ò¬¥¬®ÀÜ√é√ìÀáÀú√ç‚Äî√ö≈í√î\uF8FFÀõƒ±√Ç‚Äû‚óä¬∏")

(= dvorak-fingers '("'a;" ",oq" ".e" "pyuijkx" "fgdhbm" "ctw" "rnv" "lsz/-=")
   qwerty-fingers '("qaz" "wsx" "ed" "rtfgcvb" "yuhjnm" "ik," "ol." "p;/'[]"))




;((A 1) (B 1) (C 3) (D 4) (E 6))
;->
;(((A . B) 2) (C 3) (D 4) (E 6))
;->
;((D 4) (((A . B) . C) 5) (E 6))
;->
;((E 6) ((D . ((A . B) . C)) 9))
;->
;(((E . (D . ((A . B) . C))) 15))
;->
;(E . (D . ((A . B) . C)))

(def huffman-tree (s)
  (xloop (xs nrev:count-up.s)
    (if no:cdr.xs
        caar.xs
        (next:insert-sorted (compare < cadr)
                            (with ((a an) car.xs
                                          (b bn) cadr.xs)
                              (list (cons a b)
                                    (+ an bn)))
                            cddr.xs))))

;(def niceify (tree)
;  (xloop (tree tree)
;    ;make nicer, return min-depth
;    (if atom.tree
;      0
;      (with (a next:car.tree
;             b next:cdr.tree)
;        (when (> a b)
;          (swap car.tree cdr.tree)
;          (swap a b))
;        inc.a)))
;  tree)

(def huffman-tree->table (tree)
  (w/table u
    (xloop (tr tree str "")
      (if atom.tr
          (= u.tr str)
          (do (next car.tr (string str "0"))
              (next cdr.tr (string str "1")))))))

(def hencode-string (s)
  (let u huffman-tree->table:huffman-tree.s
    (string:map u (as cons s))))

(def hdecode-string (tree s)
  (xloop (i 0 tr tree str "")
    (if atom.tr
        (next i tree (string str tr))
        (is i len.s)
        str
        (next inc.i
              (case s.i
                #\0 car.tr
                #\1 cdr.tr)
              str))))

(def bit-string->byte-list (s)
  (join (map [digs->num (map int:string _) 2]
             (tuples 8 (as cons s)))
        (inc:mod dec:len.s 8)))

;OH FUCK DON'T KNOW HOW TO EOF
;OH MAN SOLUTION IS TO PRINT, AS THE LAST BYTE, n in [1..8]
; DESCRIBING HOW MANY BITS THERE WERE IN THE PREVIOUS BYTE
(def pr-bits (s) ;s is string of 0 and 1 chars
  (no:map writeb bit-string->byte-list.s))

(def read-bits ((o p (stdin)))
  (string:let u (drain readb.p)
    (let (main rest) (split u (- len.u 2))
      (apply join (join (map [num->digs _ 2 8] main)
                        (let (x n) rest
                          (list:num->digs x 2 n)))))))

(def gviz (tree)
  (pr "digraph G { ")
  (xloop (tree tree name "x")
    (if atom.tree
        (pr name " [label=\"" tree "\",shape=plaintext];")
        (with (a (string name "0") b (string name "1"))
          (pr name " -> " a "; " name " -> " b ";")
          (pr name " [label=\"\",shape=circle,width=.04,height=.04];")
          (next car.tree a)
          (next cdr.tree b))))
  (prn "}"))

(def tll (x (o line 80))
  (for i 0 (div len.x line)
    (prn:cut x (* i line) (min len.x (* inc.i line)))))

(def ds (x) (sort < dedup.x))
(def coprime (x y) (is 1 (gcd x y)))
(def is-square-mod (a p) ;Euler's criterion (p is prime)
  (if prime.p
      (or (is p 2) (is 1 (mod-expt a (/ dec.p 2) p)))
      (find-int [is 0 (mod (- square._ a) p)] 0 dec.p)))

(def scp ()
  (eval (list '$ (cons 'begin (readall:pbpaste)))))

(def sign (x)
  (if (> x 0)
      1
      (< x 0)
      -1
      0))
(def stddev args
  (sqrt:/ (reduce + args) len.args))

(let orig queue
  (= queue (fn args
             (let q (orig)
               (map [enq _ q] args)
               q))))

(defmemo look-say (n)
  (case n 0 '(1) flat1:collect:look-say:dec.n))

(def mat-order (mat m)
  (let u mat-id:len.mat
    (xloop (x mat n 1)
      (if (iso u x)
          n
          (next (mat-mul-mod x mat m) inc.n)))))

;(def lin-rec (inits new (o raw nil))
;  (let f nil
;    (= f (if raw
;             (memo:fn (n m)

(def triang (n)
  (* 1/2 n (+ n 1)))

;(defmemo M (z x y) ;intuitive, but we can do faster
;  "Alex's Mt Mahonia. Name conflict with 2D version."
;  (if (is z 0)
;      (if (is x y 0) 1 0)
;      (or (< x 0) (< y 0))
;      0
;      (sum (fn (i)
;             (sum (fn (j) (M (- z 1) (- x i) (- y j))) 0 i))
;           0 z)))

(defmemo M (z x y)
  "Alex's Mt Mahonia. Name conflict with 2D version."
  (if (is z 0)
      (if (is x y 0) 1 0)
      (or (< x 0) (< y 0))
      0
      (+ (M z dec.x y)
         (sum (fn (i)
                (- (M dec.z (- x i) (- y i))
                   (M dec.z (- dec.x z) (- y i))))
              0 z))))

($:define (mat-mul-mod-into x y dest a c b m)
  (do ((i 0 (+ i 1))
       (sh-i 0 (+ sh-i c)))
      ((= i a))
      (do ((j 0 (+ j 1))
           (ij (* i b) (+ ij 1)))
          ((= j c))
          (do ((k 0 (+ k 1))
               (ik sh-i (+ ik 1))
               (kj j (+ kj b))
               (tt 0 (modulo (+ tt (modulo (* (vector-ref x ik) ;this extra mod should be
                                              ;much better. in practice it is a bit better.
                                              (vector-ref y kj)) m)) m)))
              ((= k b) (vector-set! dest ij tt))))) ;can do an assigmnent at the end... seems
  ;to be not better, possibly worse, for some reason. oh well.
  dest)
(= mmmi $.mat-mul-mod-into)

(def mat-mod-expt (mat n m)
  (let nn len.mat
    (xloop (a  (apply vec flat.mat)
            n  n
            tt (apply vec flat:mat-id.nn)
            xt (apply vec (n-of square.nn 0)))
      ;(prsn a n tt xt)
      (if (is n 0)
          (tuples nn (mapn [vref tt _] 0 dec:square.nn))
          even.n
          (next (mmmi a a xt nn nn nn m)
                (div n 2)
                tt
                a)
          (next a
                (- n 1)
                (mmmi a tt xt nn nn nn m)
                tt)))))

(def binary-search (low-enough a b)
  (if (is a b)
      a
      (is (+ a 1) b)
      (if low-enough.b b a)
      (let u (div (+ a b) 2) ;rounds... toward 0, fuck
        (if low-enough.u
            (binary-search low-enough u b)
            (binary-search low-enough a (- u 1))))))

(def hax (m p) ;matrix order ;version 3
  (if no:prime.p
      (err "Fuck you p should be prime:" p)
      (withs (n len.m
              idm mat-id.n
              us (mapn [- (expt p n) (expt p _)] 0 dec.n))
        ;First pass: See if you can remove the big factors.
        ;It is optimal to start with the p^n - 1 factor.
        ;Yields 4-5x improvement for a particular 5x5 matrix on primes up to 8000.
        (xloop (us us bfacts nil xp (reduce * us))
          (if no.us
              (xloop (facts (count-up:mappend factor bfacts) xp xp)
                (if no.facts
                    xp
                    (let (q pow) car.facts
                      (next cdr.facts
                            (/ xp (expt q (binary-search [iso idm (mat-mod-expt m (/ xp (expt q _)) p)]
                                                         0 pow)))))))
              (iso idm (mat-mod-expt m (/ xp car.us) p))
              (next cdr.us bfacts (/ xp car.us))
              (next cdr.us (cons car.us bfacts) xp))))))

(def recmat (revpoly)
  (unless (is 1 car.revpoly)
    (err "Leading coeff should probably be 1."))
  (cons (map - cdr.revpoly)
        (let n dec:len.revpoly
          (mapn (compose [if _ 1 0] is) 0 (- n 2) 0 dec.n))))

(def rmod (x m)
  (let u (div m 2)
    (- (mod (+ x u) m) u)))

(def div-mod (a b m)
  (zaps [mod _ m] a b)
  (if (is b 0)
      +inf.0
      (mod (* a (inv b m)) m)))

;expresses x as, e.g., 1/5(p-1)(p^2+p+1)
;problem: unable to recognize, e.g., 2(p+1); that will
; be written as 1/[p-1 / 2](p-1)(p+1)
(def ld (x p)
  (xloop (z 1)
    (let (rest facts)
      (with (x (* x z) facts nil)
        (let tf (fn (fact val)
                    (while (divides fact x)
                      (push val facts)
                      (zap / x fact)))
          ;problem: if I divide out p+1 first, and if 1+p+p^2+p^3 was a factor,
          ;then 1+p^2 will be the remaining factor, which would require more
          ;sophistication to recognize.
          ;solution: count all the way up to 1+p+...+p^hella-big,
          ;then count down.
          (tf p 0)
          (xloop (f inc.p i 1)
            (if (> f x)
                (xloop (f f i i)
                  (unless (< i 1)
                    (tf f i)
                    (next (/ (- f 1) p) dec.i)))
                (next (+ 1 (* p f)) inc.i)))
          (and (> p 2) (tf dec.p -1))
          ;(prsn z x facts)
          (list x facts)))
      (if (is rest 1)
          (string:map [if (isa _ 'int)
                      (case _
                        -1 "(p-1)"
                        0 "p"
                        1 "(p+1)"
                        (string "("
                                (rev:mapn [string "p^" _ "+"] 2 _)
                                "p+1)"))
                      _]
                  ((if (is z 1)
                       idfn
                       [cons list:/.z _])
                   (sort > facts)))
          (> z (- p 3))
          "WTF"
          next:inc.z))))

(def ldu (x p n)
  (xloop (z 1)
    (let (rest facts)
      (with (x (* x z n) facts nil)
        (let tf (fn (fact val)
                    (while (divides fact x)
                      (push val facts)
                      (zap / x fact)))
          ;problem: if I divide out p+1 first, and if 1+p+p^2+p^3 was a factor,
          ;then 1+p^2 will be the remaining factor, which would require more
          ;sophistication to recognize.
          ;solution: count all the way up to 1+p+...+p^hella-big,
          ;then count down.
          (tf p 0)
          (xloop (f inc.p i 1)
            (if (> f x)
                (xloop (f f i i)
                  (unless (< i 1)
                    (tf f i)
                    (next (/ (- f 1) p) dec.i)))
                (next (+ 1 (* p f)) inc.i)))
          (and (> p 2) (tf dec.p -1))
          (and (> n 1) (tf n -.n))
          ;(prsn z x facts)
          (list x facts)))
      (if (is rest 1)
          (string (when (>= z (div dec.p n)) "amb: ")
                  (string:map [if (isa _ 'int)
                                  (case _
                                    -1 "(p-1)"
                                    0 "p"
                                    1 "(p+1)"
                                    (if (< _ 0)
                                        string:-._
                                        (string "("
                                                (rev:mapn [string "p^" _ "+"] 2 _)
                                                "p+1)")))
                                  _]
                              ((if (is z 1)
                                   idfn
                                   [cons list:/.z _])
                               (sort > facts))))
          (> z (- p 3))
          "WTF"
          next:inc.z))))

;So now I have a justification for crap. I know that the period will be a product of divisors of p^n - 1, where
;n ranges over the degrees of the irreducible factors of the polynomial mod p.
;Note, btw, that gcd(p^a - 1, p^b - 1) = p^(gcd(a,b)) - 1.
;... EXCEPT WHEN ROOTS ARE REPEATED.  Then weird shit may happen. Consider the recurrence f(n+2) = 2f(n+1) - f(n).
;(def ldd (x p n)
;  (with (facts nil)
;    (let rf (fn (fact val)
;              (zap / x fact)
;              (push val facts))
;      (xloop (

(def bit-set (x n)
  ($.tnil ($.bitwise-bit-set? x n)))
(= bit-and $.bitwise-and
   bit-or  $.bitwise-ior
   bit-ior  $.bitwise-ior)

(= str tostring:pr)

(def zero (x)
  ($.tnil ($.zero? x)))

(def integer (x)
  (isa x 'int))

#;(redef inc (x) (coerce (+ (coerce x 'int) 1) type.x))
; ^ hella confusing with non-integers
(redef inc (x)
  (if ($.number? x)
      (+ x 1)
      (coerce (+ (coerce x 'int) 1) type.x)))

(def xor args ;noob doesn't need to be a macro
  (xloop (args args x nil)
    (if no.args
        x
        car.args
        (next cdr.args no.x)
        (next cdr.args x))))

(redef readline ((o s (stdin)))
  (aif (readc s)
    (string
     (accum a
       (xloop (c it)
         (if (is c #\return)
              (if (is (peekc s) #\newline)
                   (readc s))
             (is c #\newline)
              nil
              (do (a c)
                  (aif (readc s)
                        (next it)))))))))

(redef reduce (f xs)
  (if no.xs
      (f)
      ((fn (func)
         (func func car.xs cdr.xs))
       (fn (func x xs)
         (if no.xs
             x
             (func func (f x car.xs) cdr.xs))))))


(def mmod (x m)
  (div-mod numer.x denom.x m))
(def linear-factor-mod (poly p)
  (xloop (i 0 poly poly facs nil)
    (if (iso poly '(1))
        nrev.facs
        (is i p)
        (join nrev.facs list.poly)
        (let (q r) (map [dezero:map [mmod _ p] _] (q/r-poly poly (list i 1)))
          (if no.r
              (next i q (cons (list i 1) facs))
              (next inc.i poly facs))))))

(def factor-mod (poly p)
  (xloop (i 0 poly poly facs nil msiz (expt p (div degree.poly 2)))
    (if (iso poly '(1))
        nrev.facs
        (no:< i msiz)
        (join nrev.facs list.poly)
        (let fac (cons 1 (or (num->digs i p) '(0)))
          (let (q r) (map [dezero:map [mmod _ p] _] (q/r-poly poly (list i 1)))
            (if no.r
                (next i q (cons (list i 1) facs) (expt p (div degree.q 2)))
                (next inc.i poly facs msiz)))))))

(def vfind-int (f (o n 0) (o m nil))
  (let gud (rfn gud (n)
             (if (< n 10)
                 (in n 1 2 5)
                 (and (divides 10 n)
                      (gud:div n 10))))
    (xloop (n n)
      (if (and m (> n m))
          nil
          f.n
          n
          (do (when gud.n prn.n)
            next:inc.n)))))

(mac ttime body
  (w/uniq gtime
    `(let ,gtime (msec)
       ,@body
       (- (msec) ,gtime))))

(def prim-root (p)
  (unless prime.p (err "FUCK YOU"))
  (let facs dedup:factor:dec.p
    (find-int (fn (n) (all [isnt 1 (mod-expt n (div dec.p _) p)] facs)) 2 dec.p)))

(def prim-roots (p)
  (let root prim-root.p
    (sort < (map [mod-expt root _ p] (keep [is 1 (gcd _ dec.p)] (range 1 dec.p))))))

(def bsf (n) ;bit scan forward, named from x86
  (dec:int-len:- n (bit-and n (- n 1))))

;tonelli-shanks from wikipedia
;NB. can be generalized to the kth root of a thing from any cyclic group.
(def mod-sqrt-prime (n p)
  (if (is p 2)
      (mod n 2)
      (divides p n)
      0
      no:prime.p
      (err:string p " is not prime.")
      (isnt 1 (mod-expt n (/ dec.p 2) p))
      (err:string n " is not a square mod " p ".")
      (withs (s bsf:dec.p q (ash dec.p -.s))
        (xloop (x (mod-expt n q p)
                c (mod-expt (find-int [isnt 1 (mod-expt _ (/ dec.p 2) p)] 1 dec.p) q p)
                m s
                r (mod-expt n (/ inc.q 2) p))
          ;we maintain r^2 = xn.
          ;c is a primitive (2^m)th root of unity mod p.
          (if (is x 1)
              r
              (withs (i (xloop (i 0 x x) (if (is x 1) i (next inc.i (mod square.x p))))
                      b (mod-expt c (expt 2 (- m i 1)) p))
                ;so x is a primitive 2^ith root of unity.
                ;note that i should be less than m.
                ;now b is a 2^(i-1)th root of unity.
                ;in next step, we might need the ith root of unity for r, so.
                (next (mod (* x b b) p)
                      (mod (* b b) p)
                      i
                      (mod (* r b) p))))))))

(def mod-sqrt (n m)
  (if (< m 2)
      (if (is m 1) 0 (err "How do I mod-sqrt?" n m))
      (apply chr
             (mappend (fn ((p e))
                        (list (mod-sqrt-prime-pow n p e)
                              (expt p e)))
                      count-up:factor.m))))

;suppose a^2 = n (mod p^k-1), k >= 2.
;consider (a + x*p^k-1)^2 mod p^k, for unknown x mod p.
;since k>=2, 2k-2 >= k, so the last term dies
;and we're left with a^2 + 2ax*p^k-1 mod p^k.
;now, a^2 = n + y*p^k-1 (p^k) for some y mod p.
;if we pick x such that 2ax = y mod p, i.e. x = y/2a mod p,
;then a + x*p^k-1 is sqrt(n) mod p.
(def mod-sqrt-prime-pow (n p e)
  (if (is e 1)
      (mod-sqrt-prime n p)
      (divides p n) ;fuckin' special case
      (if (divides square.p n)
          (* p (mod-sqrt-prime-pow (div n square.p) p (- e 1)))
          (err:string n " has an odd power of " p ", so it has no sqrt mod " p "."))
      ;now there's a fuckin' special case about p=2, as well.
      ;it's because we're dealing with a power of 2, and (a+x*p^k-1)^2 = a^2 + 2axp^k-1 + ....
      ;if this were cube roots, then (a+x*p^k-1)^3 = a^3 + 3axp^k-1 + ... and we'd s.c 3.
      ;All right.
      ;We have a nailed down to 2^k-1, i.e. a mod 2^k.
      ;Want to know what 2^k digit should be.
      ;(a + x*2^k) = a^2 + ax*2^k+1 + x^2*2^2k
      ;incidentally a will be odd, but we don't need to use that, just it's coprime to p.
      ;now... if k >= 2, then we can ignore the last term mod 2^k+2.
      ;we hope by previous induction that a^2 has the right 2^k-1 digit.
      ;then n^2 - a^2 is multiple of 2^k.
      ;then we can say n^2 - a^2 = y*2^k+1 mod 2^k+2
      ;and so ax = y; x = y/a.
      ;this requires k >= 2 and a^2 = n mod 2^k.
      ;now, e = k+1.
      (with (a (mod-sqrt-prime-pow n p dec.e) p^e-1 (expt p dec.e))
        (if (is p 2)
            (if (is e 2)
                (or (find-int [divides (expt p 3) (- n square._)] 0 (dec:expt p e))
                    (err:string n " is not a square mod " (expt p e) ">"))
                (+ a (* p^e-1
                        (div-mod (/ (- n square.a) (expt p e))
                                 a
                                 p))))
            (+ a (* p^e-1
                    (div-mod (/ (- n square.a) p^e-1)
                             (* 2 a)
                             p)))))))


(def prtab (x)
  (each (x y) (sort errsafe:before tablist.x)
    (prsn x y)))

(def vigenere (str keyword)
  (let i 0
    (map [if letter._
             (do1 (caesar-shift1 _ keyword.i)
                  (= i (mod inc.i len.keyword)))
             _]
         str)))

(def ngon (n x)
  (eval-poly (gp:list 0 1 n) x))

(def gon (n)
  (let u (gp:list 0 1 n)
    [eval-poly u _]))

(def hexify (n (o d))
  (string:map [if (> _ 9) (char:+ (int #\A) _ -10) _]
              (num->digs n 16 d)))

($:require mzlib/os)
(= process-id $.getpid)

(= front-row-name "/System/Library/CoreServices/Front Row.app/Contents/MacOS/Front Row"
;   monitor-string (string "ps ax | grep '" front-row-name
;                          "' | grep -v grep && echo meh && kill -INT " (process-id));useful to kill other threads
   monitor-string (string "ps ax | grep '" front-row-name "' | grep -v grep")
   monitor-thread nil
   main-thread (current-thread))

(def make-monitor ()
  (= monitor-thread (thread:while t sleep.1
                                  (unless empty:sys.monitor-string
                                    break-thread.main-thread
                                    kill-thread.monitor-thread))))
(def kill-monitor ()
  kill-thread.monitor-thread)

(defmemo partitions (n (o max n))
  (if (is n 0)
      list.nil
      (or (< n 0) (is max 0))
      nil
      (join (map [cons max _] (partitions (- n max) max))
            (partitions n dec.max))))

(defmemo distinct-partitions (n (o max n))
  (if (is n 0)
      list.nil
      (or (< n 0) (is max 0))
      nil
      (join (map [cons max _] (distinct-partitions (- n max) dec.max))
            (distinct-partitions n dec.max))))


(let sept gon.7
  (defmemo upart (n)
    (if (is n 0)
        1
        (< n 0)
        0
        (+ (sum [* (expt -1 inc._) (upart:- n sept._)] 1 (integer-finverse sept n))
           (sum [* (expt -1 inc._) (upart:- n sept._)] (-:integer-finverse sept:- n) -1)))))


(delay-def recurrence (m zer-case) ;NO ONE-VAL
  (let mgon gon.m
    (let f nil
      (= f (memo:fn (n)
                    (if (<= n 0)
                        (err "undefined at" n)
                        (+ (sum [if (is _ 0)
                                    0
                                    (* (expt -1 inc._)
                                       (if (is mgon._ n)
                                           zer-case.n
                                           (f:- n mgon._)))]
                              (-:integer-finverse mgon:- n)
                              (integer-finverse mgon n)))))))))

(delay-def mul-part-recurrence (m one-val zer-case)
  (let partition (recurrence m 1 [id 1])
    (let mgon gon.m
      (let f nil
        (= f (memo:fn (n)
                      (if (<= n 0)
                          (err "undefined at" n)
                          (is n 1)
                          one-val
                          (+ (sum [if (is _ 0)
                                      0
                                      (* (expt -1 inc._)
                                         mgon._
                                         (if (is mgon._ n)
                                             zer-case.n
                                             (partition:- n mgon._)))]
                                  (-:integer-finverse mgon:- n)
                                  (integer-finverse mgon n))))))))))

;u = 1 + r + ... + r^n
;ur = r^n+1 - 1 + u
;u = (r^n+1 - 1) / (r-1)
(def sum-of-divisors (n)
  (reduce * (map (fn ((x e))
                   (/ (dec:expt x inc.e) dec.x))
                 count-up:factor.n)))

(def try-dicks (f (o n 30) (o try-factor 5) (o tolerance 1/2) (o limit 4))
  (for m 2 n
    (when (is 1 len:dedup:factor.m)
      (for i 0 dec.m 
        (let u (count-up:mapn [mod (f:+ (* m _) i) m] 1 (* try-factor n))
          (when (and (<= (/ len.u m) tolerance) (<= len.u limit))
            (prsn m i "->" u)))))))

;(def try-dicks (f (o n 30) (o try-factor 5) (o tolerance 1/2) (o limit 4))
;  (let tb (table)
;    (for m 2 n
;      (when (is 1 len:dedup:factor.m)
;        (for i 0 dec.m 
;          (let u (count-up:mapn [mod (f:+ (* m _) i) m] 1 (* try-factor n))
;            (when (and (<= (/ len.u m) tolerance) (<= len.u limit))
;            (prsn m i "->" u)))))))

(def tf (x)
  (if (is x nil)
      ($.not t)
      ($.not ($.not t))))

(def take-one-value (thunk)
  ($.call-with-values thunk ($:lambda (x . args) x)))
(mac one-value (expr)
  `(take-one-value (fn () ,expr)))

(def shell-butt (str (o stout (stdout)) (o stin (stdin)) (o sterr (stderr)))
  (one-value ($.subprocess stout stin sterr
                           (prn:sys "which sh | tr -d '\n'")
                           "-c"
                           str)))

(def subprocess-kill (x (o force t))
  ($.subprocess-kill x tf.force))

(def l-fn (x)
  (stfu:load:find file-exists
             (all-choices (fn args
                            (reduce (fn (x f) (f x))
                                    (cons x args)))
                          (list idfn [string src-directory _])
                          (list idfn [string _ ".arc"]))))
(mac l (x)
  (let u (if (is x 'l) last-l x)
    `(do (l-fn ',(string u))
       ,(if (is x 'l)
            `',u
            `(do (= last-l ',x) nil)))))

(def fn-reduce (x fs)
  (if no.fs
      x
      (fn-reduce car.fs.x cdr.fs)))

(= bracket-fn
   (macro args
     `(fn ,(let u (sort < (dedup:keep [and (isa _ 'sym)
                                           (is 0 (pos #\_ string._))]
                                      (flat:map [if ssyntax._
                                                    ssexpand._
                                                    _]
                                                flat.args)))
             (if (mem '__ u)
                 (append (rem '__ u) '__)
                 no.u
                 '__ ;now things like [uniq] take n args
                 u))
        ,@args)))
#;(= bracket-fn (macro args
                `(fn ,(let u (sort < (dedup:keep [and (isa _ 'sym)
                                                      (is 0 (pos #\_ string._))]
                                                 flat.args))
                        (append (or (rem '__ u) '(_))
                                (find '__ u)))
                   ,@args)))

(def list* args
  (if no.args
      nil
      no:cdr.args
      car.args
      (cons car.args (apply list* cdr.args))))

(= fail* ($:gensym 'fail-sym)) ;Gotcha:
;(hash-ref hash key [failure-result]) --> any
;If failure-result is a procedure, it is called (through a tail call) with no arguments to produce the result.








(def bits (n) (num->digs n 2))

(= move-program "~/move"
   click-program "~/click")


(= move (fn (x y)
          (system:tostring:prsn move-program x y)))

(= click (fn args
           (when args
             (let (x y) args
               (move x y)))
           (system click-program)))

(mac forz (vars a b . body)
  (w/uniq (gstart gstop)
    `(with (,gstart ,a ,gstop ,b)
       ,(xloop (vars vars low gstart)
           (if no.vars
               `(do ,@body)
               `(for ,(car vars) ,low ,gstop
                   ,(next cdr.vars car.vars)))))))

($:require racket) ;derf
(= process $.process) ;doesn't exist in "Pretty Big"
(def call-with-pipe-to (str thunk)
  (let (stout stin pid sterr status-func) (process str)
    (after (w/stdout stin (thunk))
           (close stin)
           ($.write-bytes ($.port->bytes stout)))))

(mac pipe-to (str . body)
  `(call-with-pipe-to ,str (fn () ,@body)))

(def call-with-pipe-from (str thunk)
  (let (stout stin pid sterr status-func) (process str)
    (w/stdin stout
      (thunk))))

(mac to-clipboard body
  `(pipe-to "pbcopy" ,@body))

(def safe-isqrt (n)
  (let u isqrt.n
    (and (is n square.u)
         u)))

(def sorted (< xs)
  (or no.xs
      no:cdr.xs
      (and (< car.xs cadr.xs)
           (sorted < cdr.xs))))

(= dvorak-keycode (table))
(each (x y) (tuples 2 '(0 a
                        1 o
                        2 e
                        3 u
                        4 d
                        5 i
                        6 #\;
                        7 q
                        8 j
                        9 k
                        11 x
                        12 #\'
                        13 #\,
                        14 #\.
                        15 p
                        16 f
                        17 y
                        18 1
                        19 2
                        20 3
                        21 4
                        22 6
                        23 5
                        24 #\]
                        25 9
                        26 7
                        27 #\[
                        28 8
                        29 0
                        30 #\=
                        31 r
                        32 g
                        33 #\/
                        34 c
                        35 l
                        36 enter
                        37 n
                        38 h
                        39 -
                        40 t
                        41 s
                        42 #\\
                        43 w
                        44 z
                        45 b
                        46 m
                        47 v
                        48 (tab #\tab)
                        49 (space #\space)
                        50 (#\` backquote)
                        123 (left-arrow left)
                        124 (right-arrow right)
                        125 (down-arrow down)
                        126 (up-arrow up)))
  (each name (if acons.y y list.y)
    (= dvorak-keycode.name x)
    (if (and (isa name 'sym) (is 1 len:string.name))
        (= (dvorak-keycode string.name.0) x))))


(= delete-file $.delete-file)

(def ceiling-log (x (o b 2))
  (let u (integer-finverse [expt b _] x)
    (if (is x (expt b u))
        u
        (+ u 1))))

(def is-sorted (< xs)
  (or no:cdr.xs
      (and (< car.xs cadr.xs)
           (is-sorted < cdr.xs))))

(with (scale (fn (row x m)
               (map [mod (* _ x) m] row))
       sub (fn (a b m)
             (map [mod (- _a _b) m] a b)))
  (def invert-mod (xs m)
    (let sx mat-id:len.xs
      (forlen n xs
        (let f (fn (x)
                 (zaps [scale _ x m] xs.n sx.n)
                 (for i inc.n dec:len.xs
                   ((fn (f) (f xs) (f sx))
                    (fn (xs)
                      (zap [sub _ (scale xs.n _.n m) m] xs.i)))))
          (aif (inv xs.n.n m)
               f.it
               (pos [inv _.n m] xs n)
               (do (swap xs.n xs.it)
                 (swap sx.n sx.it)
                 (zaps [scale _ -1 m] xs.n sx.n)
                 (f:inv xs.n.n m))
               (err "No inverse?" n xs sx))))
      (for- n dec:len.xs 1
        (for- i dec.n 0
          ((fn (f) (f xs) (f sx))
           (fn (xs)
             (zap [sub _ (scale xs.n _.n m) m] xs.i)))))
      sx)))

(= on
   (macro (var s . body)
     (if (is var (quote index))
         (err "Can't use index as first arg to on.")
         `(let index 0
            (each ,var ,s
              ,@body
              (++ index))))))

(= floor-div ($:lambda (x d)
               (define (meh)
                 (let-values (((q r) (quotient/remainder x d)))
                   (if (zero? r)
                       q
                       (- q 1))))
               (if (> x 0)
                   (if (> d 0)
                       (quotient x d)
                       (meh))
                   (if (< d 0)
                       (quotient x d)
                       (meh))))
   ceiling-div ($:lambda (x d)
                 (define (meh)
                   (let-values (((q r) (quotient/remainder x d)))
                     (if (zero? r)
                         q
                         (+ q 1))))
                 (if (> x 0)
                     (if (> d 0)
                         (meh)
                         (quotient x d))
                     (if (< d 0)
                         (meh)
                         (quotient x d)))))

(= mismatch
   (fn (x y)
     (if (and acons.x acons.y)
         (xloop (x x y y i 0)
           (if no.x
               (and y i)
               (or no.y (isnt car.x car.y))
               i
               (next cdr.x cdr.y inc.i)))
         (or (find-int [isnt x._ y._] 0 (dec:min len.x len.y))
             (and (isnt len.x len.y) (min len.x len.y))))))

(def wget (url (o verbose t) (o name) (o dry-run))
  ((if dry-run idfn system)
   (string "wget "
           (if no.verbose "-q ")
           (if name (string "-O \""
                            (subst "\\\"" "\"" name)
                            "\" "))
           "\"" url "\"")))

;All right, it's time to define "with" in the hardcore way.
;type 1: (with a (blah) b (bleh) (nerb a b))
;type 2: (with (a (blah) b (bleh)) (nerb a b))
;these are distinguished by whether the first argument to "with"
;is a symbol or a cons. nil will be treated as an empty bindings list.
;If you want destructuring, you have to use type 2.
;... fuck, I screwed this up earlier
#;(= with (macro (bind . rest)
          (if (or acons.bind no.bind)
              `((fn ,(map car (tuples 2 bind))
                  ,@rest)
                ,@(map cadr (tuples 2 bind)))
              (let xs (tuples 2 (cons bind rest))
                (let (binds body)
                     (split xs (or (pos (compose no (andf [isa _ 'sym] no:ssyntax) car) xs)
                                   len.xs))
                  `((fn ,(map car binds) ,@(apply join body))
                    ,@(map cadr binds)))))))
(= with (macro (bind . rest)
          (if no.bind
              `(do ,@rest)
              alist.bind
              (let xs (tuples 2 bind)
                `((fn ,(map car xs) ,@rest)
                  ,@(map cadr xs)))
              ;type 2: (with x (dick) y ass (blarg) (blarg) (blarg))
              ;(roughly)
              (isa bind 'sym)
              (let xs (cons bind rest)
                (let n (or (pos (compose no (andf [isa _ 'sym] no:ssyntax) car)
                                (tuples 2 xs))
                           (div len.xs 2))
                  `(with ,(take (* 2 n) xs)
                     ,@(drop (* 2 n) xs))))
              (err "With what?" bind)))) ;disallows improper lists

(mac assert (expr)
  `(unless ,expr
     (err "Failed assertion:" ',expr)))

;So the problem is now that I want to be like
;(with (arc crap)
;  (scheme exprs containing (), where () had better not -> null)).

($:define-syntax fuck-case-lambda 
                 (syntax-rules (TOTALLY-NOT-NULL)
                   ((fuck-case-lambda
                     ((TOTALLY-NOT-NULL) a ...)
                     b ...)
                    (case-lambda
                      (() a ...)
                      b ...))
                   ((fuck-case-lambda a ...)
                    (case-lambda a ...))))

(mac case-fn cases
  (assert (divides 2 len.cases))
  (let names (n-of (/ len.cases 2) (uniq))
    `(with ,(flat1:map (fn (name (pattern expr))
                         `(,name (fn ,pattern ,expr)))
                       names (tuples 2 cases))
       ($:fuck-case-lambda
        ,@(($:lambda (x) ;oh god so bad: "nil" is an arglist matching everything
                     #;(set! _the-x x)
                     (let loop ((x x))
                       #;(set! _last-x x)
                       (if (null? x) x
                           (cons (if (eq? (caar x) 'nil)
                                     (cons '(TOTALLY-NOT-NULL) (cdar x))
                                     (car x))
                                 (loop (cdr x))))))
           ($.ac-denil
            (map (fn (name (pattern expr))
                   (list pattern (if (or acons.pattern no.pattern)
                                     `(,name ,@pattern)
                                     `(apply ,name ,pattern))))
                 names (tuples 2 cases))))))))

(= defmemo (macro (name parms . body)
             `(do (safeset ,name (memo (fn ,parms ,@body)))
                (= (sig ',name) ',parms))))
(= c-int-name (table))
(each (name n) (tuples 2 '(char 8 short 16 int 32 long 64))
  (= (c-int-name:symb 'i n) string.name
     (c-int-name:symb 'u n) (string "unsigned " name)))

(def derf-mat-order (mat m)
  (let b (table)
    (xloop (x mat n 1)
      (if b.x
          (hurf-mat-order mat m (- n b.x))
          (do (= b.x n)
            (next (mat-mul-mod x x m) (+ n n)))))))

(def find-smallest-divisor (test n) ;doesn't test n itself; try to test small numbers
  (if prime.n
      n
      (xloop (facs nrev:collect:factor.n n n)
        (if no.facs
            n
            (let (p x) car.facs
              (let u (binary-search [test:div n (expt p _)] 0 x)
                (next cdr.facs (div n (expt p u)))))))))

(def hurf-mat-order (mat m nn)
  (let u mat-id:len.mat
    (unless (iso u (mat-mod-expt mat nn m))
      (err "Obviously this matrix isn't invertible mod m" mat m nn))
    (find-smallest-divisor [iso u (mat-mod-expt mat _ m)] nn)))


(def s-take (n s)
  (xloop (n n s s xs nil)
    (if (or no.s (is n 0))
        nrev.xs
        (next dec.n s-cdr.s (cons s-car.s xs)))))

($:require (prefix-in c- ffi/unsafe))

(def ffi-lib (file)
  ($.c-ffi-lib file))

(def get-ffi-obj (name lib type)
  ($.c-get-ffi-obj name lib type))

;Now I've basically settled on a location and implementation
;of the asm library.
;... Ok, let's build it for the user if they don't have it yet.
;(General note: Windows has a different C calling convention,
; so asm code is pretty incompatible and not worth trying atm.)
(withs (base (string src-directory "../c-lib/racket-asm-lib")
        lib ($.path->string
             ($.path-add-suffix base $.system-type!so-suffix))
        source (string base ".c"))
  (unless file-exists.lib
    (system:string "gcc "
                   (case $.system-type!os
                     macosx "-dynamiclib "
                     unix (string "-shared -fPIC "
                                  ;And, it turns out, on Linux, I need
                                  ;for some mind-boggling reason to do
                                  ;the following to get RTLD_DEFAULT
                                  ;to get defined by dlfcn.h:
                                  "-D_GNU_SOURCE "))
                   "-o '" lib "' '" source "'"))
  (= asm-lib errsafe:ffi-lib.lib))

;So that contains a bunch of C functions that I can use to
;call byte-arrays of machine code.
;Unfortunately, I can't just use, e.g., one global "call2" function
;that applies a byte-array to two arguments.
;Racket demands that the C functions you import be given precise
;type information.  If I want to call a C function on two integers,
;and call the same function on two byte strings, I have to use two
;separate importations of the same C function into Racket, annotated
;respectively as functions of integers and of byte strings.
;I can at least be clever by importing an asm function as an Arc
;function that finds out what types it's being passed, then generates
;a Racket importation of the "call[n]" function annotated with the
;correct types.

(def dir-holding (x . dirs)
  (find [file-exists:string _ "/" x] flat.dirs))

(= asm-code-magic-number #xfffefafd
   asm-dir (string src-directory "../asm"))
(def compile-asm (name)
  (withs (file-dir (dir-holding (string name ".asm")
                                asm-dir
                                (string asm-dir "/crap"))
          base (string file-dir "/" name))
    (system:string
     "cd " file-dir "; " ;so that %include is in right dir
     "nasm -f macho64 "
     ;now let's give it some info
     (case $.system-type!os
       macosx "-DDARWIN "
       unix "-DUNIX "
       "") ;alternative would probably be Windows
     "-o " name ".o "
     name ".asm")
    (fromfile (string base ".o")
      (let n 0
        (while (isnt n asm-code-magic-number)
          (= n (bit-or (ash (or (readb) (err "No magic number?" name)) 24)
                       (ash n -8)))))
      (tofile (string base ".code")
        (whilet n (readb)
          writeb.n)))
    (string base ".code")))
(def get-asm (name)
  (let u (compile-asm name)
    (= symbol-value:symb.name ($.file->bytes u))))

(= c-type-table
   (obj uint64 $.c-_uint64
        u64 $.c-_uint64
        uint $.c-_uint64
        int64 $.c-_int64
        i64 $.c-_int64
        int $.c-_int64
        int32 $.c-_int32
        uint32 $.c-_uint32
        int8 $.c-_int8
        uint8 $.c-_uint8
        string $.c-_string
        bytes $.c-_bytes
        ))

(def corresponding-c-type (x)
  (if ($.bytes? x) $.c-_bytes
      (isa x 'int) $.c-_uint64
      (isa x 'string) $.c-_string/ucs-4
      (err "What is the c-type of this?" x)))

(def cprocedure (arglist (o res $.c-_int64))
  ($.c-_cprocedure (apply $.list
                          (map [or c-type-table._ _] arglist))
                   (or c-type-table.res res)))

(def c-types args
  (apply $.list (map corresponding-c-type args)))

;So I provide two ways to call asm code.
;One is to directly jump to the Racket byte-buffer.  This is preferred.
;Unfortunately, Racket's heap having PROT_EXEC turned on seems not to
;be a guaranteed feature, and is in fact not the case on Linux.
;The second way, therefore, is to mmap some executable memory, copy the
;asm code into it, and jump to it.
;This second way also copies the executable buffer back into the Racket
;buffer.  This provides approximately the same API as the first way
;(if the code uses global variables, you can inspect them in the buffer
; afterwards).  waterhouse doesn't currently make use of this, but
;someone might in the future, and in the meantime he hates being
;overruled by a computer.
;Anyway, we will support both approaches.  The first is called "raw",
;the second is the default.

(mac ga (x (o n) (o raw))
  (let xargs (mapn [symb 'x _] 1 n)
    `(errsafe:do ;for when people load things on unprepared computers
      (get-asm ',x)
      ,(if n
           `(= ,(symb x '-thing)
               (let f nil
                 (fn (code ,@xargs)
                   (unless f
                     (= f ($.c-get-ffi-obj
                           ,(string (if raw "raw_call" "call") n)
                           asm-lib
                           ($.c-_cprocedure
                            (c-types code
                                     ,@(if raw '() '(0))
                                     ,@xargs)
                            $.c-_uint64)))
                     ,@(if raw `(= (symb x '-thing) f)))
                   (f code
                      ,@(if raw '() '(bytes-length.code))
                      ,@xargs))))
           `(bytes-length ',x)))))

(mac call-asm (f . args)
  `(,(symb f '-thing) ,f ,@args))

(= bytes-length $.bytes-length
   make-bytes $.make-bytes
   bytes-ref $.bytes-ref
   subbytes $.subbytes)

(def nums->bytes (xs (o bits 64))
  (unless (divides 8 bits) (err "Fuck you"))
  (withs (n (div bits 8)
          u (make-bytes:* n len.xs))
    (on x xs
      (for i 0 dec.n
        (($ bytes-set!) u (+ i (* n index)) (bit-and x 255))
        (zap [ash _ -8] x)))
    u))
(def bytes->nums (x (o bits 64))
  (unless (divides 8 bits) (err "Fuck you"))
  (withs (n (div bits 8))
    (mapn (fn (i) (digs->num (mapn [bytes-ref x (+ _ (* n i))] 0 dec.n) 256))
          0 (dec:div bytes-length.x n))))
(def bytes->int (x)
  (digs->num (nrev ($.bytes->list x)) 256))
(def bit-ref (x n)
  (bit-set (bytes-ref x (div n 8)) (mod n 8)))
(def set-bit (x n v)
  (($ bytes-set!) x (div n 8)
                  (let u (bytes-ref x (div n 8))
                    (if (is v 1)
                        (bit-or u (ash 1 (mod n 8)))
                        (bit-and u (bit-xor 255 (ash 1 (mod n 8))))))))

;Assumes xs is made of conses and integers.
;... jesus.
;Assume destination knows where the conses are, basically.
;Jesus.  So many things to do with it... must make a table.
;HOW ABOUT NIL??? ... 
;(= fake-nil 'FAKE-NIL) ;... fuck. oh well, little problem.
(def tree->objtable (xs)
  (withs (u ($.make-hasheq)
          n 0
          todo nil
          f [do1 (= u._ n) (++ n 1)]
          g [do1 f._ (push _ todo)]
          h [unless u._ g._])
    g.xs
    (while todo
      (let s pop.todo
        (if acons.s
            (do h:car.s h:cdr.s)
            (or no.s (isa s 'int))
            nil
            (err "Wat?" type.s s))))
    u))
;assumes table is conses and ints; sizes 16 and 8 respectively
;ints are directly there, not pointed to (this means some cleanup)
;... dammit, should maintain object order.
(def inverse-hasheq (b)
  (let u ($.make-hasheq)
    (each (k v) b
      (= u.v k))
    u))
(def objtable->memtable (b)
  (with (addr ($.make-hasheq) ub inverse-hasheq.b)
    (let n 0
      (forlen i b
        (when acons:ub.i
          (= addr:ub.i n)
          (++ n 16)))
      (= addr!length n))
    addr))


($:require rnrs/bytevectors-6)
(= int-ref ($:lambda (bytes n) (bytevector-u64-ref bytes
                                                   (bitwise-and n #xffffffffffffffff)
                                                   (endianness little))))

(def install-int (bytes offset x (o bits 64))
  (unless (divides 8 bits)
    (err "Not a multiple of 8 bits" bits))
  (if (is bits 64)
      ($ (bytevector-u64-set! bytes offset (bitwise-and x #xffffffffffffffff)
                              (endianness little)))
      (let n (div bits 8)
        (for i 0 dec.n
          (($ bytes-set!) bytes (+ offset i) (bit-and x 255))
          (zap [ash _ -8] x)))))

;this thing makes #0=(1 2 3 . #0#) into #(1 16 2 16 3 -32)
(def memtable->relative-bytes (addr)
  (let u (make-bytes addr!length)
    (each (x index) addr
      (if acons.x
          (do (install-int u index
                           (aif addr:car.x
                                (- it index)
                                (or car.x 0)))
            (install-int u (+ index 8)
                         (aif addr:cdr.x
                              (- it index)
                              (or cdr.x 0))))
          (is x 'length)
          nil
          (err "Wat?" type.x)))
    u))

;this thing makes #0=(1 2 3 . #0#) into #(1 16 2 32 3 0)
(def memtable->offset-from-start-bytes (addr)
  (let u (make-bytes addr!length)
    (each (x index) addr
      (if acons.x
          (do (install-int u index (aif addr:car.x it (or car.x 0)))
            (install-int u (+ index 8) (aif addr:cdr.x it (or cdr.x 0))))
          (err "Wat?" type.x)))
    u))

;probably nil will be 0. it won't be counted as a ptr.
(def memtable->offset-bytes+ptr-list (addr)
  (with (u (make-bytes addr!length) xs nil)
    (let f (fn (x index)
             (aif addr.x
                  (do (install-int u index it)
                    (push index xs))
                  (install-int u index (or x 0))))
      (each (x index) addr
        (if acons.x
            (do (f car.x index)
              (f cdr.x (+ index 8)))
            (err "Wat?" type.x))))
    (list u nrev.xs)))

(def vector->bytes (x)
  (nums->bytes (cons len.x x)))

(def tree->relative-bytes (x)
  memtable->relative-bytes:objtable->memtable:tree->objtable.x)

(def list->cycle (xs)
  (and xs
       (withs (head (cons car.xs nil) u head xs cdr.xs)
         (while xs
           (scdr u (cons car.xs nil))
           (zaps cdr xs u))
         (scdr u head)
         head)))
(def cycle->list (xs)
  (and xs
       (withs (head (cons car.xs nil) u head uxs cdr.xs)
         (while (isnt xs uxs)
           (scdr u (cons car.uxs nil))
           (zaps cdr uxs u))
         head)))

(def cycle-map2 (f xa xb)
  (and xa xb
       (xloop (xs (cons (f car.xa car.xb) nil) uxa cdr.xa uxb cdr.xb)
         (if (and (is uxa xa) (is uxb xb))
             (let u nrev.xs ;yes, I'm assuming I know how nrev works
               (scdr xs u)
               u)
             (next (cons (f car.uxa car.uxb) xs) cdr.uxa cdr.uxb)))))

(def rev->cycle (xs)
  (let u nrev.xs
    (scdr xs u)
    u))

#;(def cycle-map (f . xses)
  (and xses (all idfn xses)
       (xloop (xs (list:apply f (map car xses)) us (map cdr xses))
         (if (all t (map is xses us))
             rev->cycle.xs
             (next (cons (apply f (map car us)) xs) (map cdr us))))))
(def cycle-map (f . xses)
  (and xses (all idfn xses)
       (with (tt nil)
         (repeat (reduce lcm (map cycle-length xses))
           (push (apply f (map car xses)) tt)
           (= xses (map cdr xses)))
         rev->cycle.tt)))
             
(def cycle-length (xs)
  (and xs (xloop (n 1 uxs cdr.xs)
            (if (is uxs xs) n (next inc.n cdr.uxs)))))

;64-bit blocks used for ANDing in sieve of Eratos.
#;(def prime-block-cycle (p)
  ;Super dumb!
  (list->cycle:map [digs->num rev._ 2]
                   (tuples 64 (mapn [if (divides p _) 0 1] 0 (dec:* p 64)))))
;No, intolerable. 2 must cycle by itself.
(def prime-block-cycle (p)
  (xloop (offset 0 xs nil)
    (if (and xs (is offset 0))
        list->cycle:nrev.xs
        (next (mod (+ offset 64) p)
              (cons (digs->num (nrev:mapn [if (divides p _) 0 1]
                                     offset (+ offset 63)) 2) xs)))))

(def intersection (< a b)
  (and a b
       (if (is car.a car.b)
           (cons car.a (intersection < cdr.a cdr.b))
           (< car.a car.b)
           (intersection < cdr.a b)
           (intersection < a cdr.b))))
                                          
    


(def s-pos (test s (o start 0))
  (let test testify.test
    (xloop (s (s-drop start s) i start)
      (if test:s-car.s
          i
          (next s-cdr.s inc.i)))))
(def s-drop (n s)
  (if (is n 0)
      s
      (s-drop dec.n s-cdr.s)))

(def sums (xs (o start 0))
  (xloop (xs xs n start ys nil)
    (if no.xs
        nrev.ys
        (next cdr.xs (+ n car.xs) (cons n ys)))))

(def mpcs (a b) ;merge prime cycles
  (cycle-map2 bit-and a b))
(def lists->array+bytes (xs)
  (let ys (map objtable->memtable:tree->objtable xs)
    (apply $.bytes-append
           (nums->bytes:map [+ _ (* 8 len.ys)] (sums (map !length ys)))
           (map memtable->relative-bytes ys))))
(def byteses->array+bytes (xs)
  (apply $.bytes-append
         (nums->bytes:map [+ _ (* 8 len.xs)] (sums (map bytes-length xs)))
         xs))

(mac d= args
  `(do ,@(map (fn ((x y)) `(destructuring-assign ,x ,y))
              (tuples 2 args))))
(mac destructuring-assign (x y) ;most inefficient code ever
  (if no.x
      nil
      (isa x 'sym)
      `(= ,x ,y)
      acons.x
      (w/uniq (gy ga gb)
        `(let ,gy ,y
           (with (,ga (car ,gy) ,gb (cdr ,gy))
             (destructuring-assign ,(car x) ,ga)
             (destructuring-assign ,(cdr x) ,gb))))))
;    (apply $.bytes-append
 ;          (ma

;Destination knows that there are 8 primes... for now.
#;(def passed-prime-blocks (primes)
  (unless (is len.primes 8)
    (err "Nerf, I want 8 primes" primes))
  (let xs (map prime-block-cycle primes)
    (
     
     
     )))

(do
 (ga eratos4 6)
 (ga anding 6)

 (def combine-prime-blocks (xs)
   ;each element is "byte-thing", with len 16 * cycle-len.
   ;and there can be at most five things
   (if (> len.xs 5)
       (err "I'm lazy.")
       (withs (clen (reduce * (map [/ bytes-length._ 16] xs))
               bs (make-bytes:* 16 clen))
;         prn!cpb
;         prn.clen
;         prn:bytes-length.bs
 ;        (err "meh")
         (install-int bs 0 clen)
         (install-int bs 8 len.xs)
         (apply anding-thing anding
                bs
                (join xs
                      (n-of (- 5 len.xs) car.xs))) ;needed for compat...
         bs)))

 (def prime-bits (n (o big-cycle-len 10000) (o cycle-steps 1) (o max-cycle-primes 256))
   (when (> n 0)
     (= n (bit-and (+ (+ n 1) 63) -64)) ;bump up to have 0-n not 0-n-1
     (let blen (div n 8)
       (let b (make-bytes blen #b10101010)
         (set-bit b 1 0)
         (eratos4-thing eratos4
                        b (min blen 32) ;# bytes for initial eratos; primes up to 8*this
                        3 ;finish with btr; unsophisticated
                        2
                        0 (make-bytes 1)) ;the last argument for compatibility...
         (with (ps (keep [bit-ref b _] (range 2 (dec:min n max-cycle-primes)))
                used-ps list.2
                max-len (min big-cycle-len n)) ;total cycle length
           ;there are 54 primes up to 256, so it works...
           (repeat cycle-steps
             (let cycs nil
               (repeat 8
                 (if ps
                     (with (using-ps nil blocks nil max-len max-len i 5)
                       (until (or (is i 0) (is max-len 0))
                         (-- i)
                         (withs (u pop.ps uu prime-block-cycle.u)
                           (if (> cycle-length.uu max-len)
                               (do (push u ps) (= max-len 0))
                               (do (push tree->relative-bytes.uu blocks)
                                 (push u using-ps)
                                 (zap div max-len cycle-length.uu)))))
                       (push (combine-prime-blocks blocks) cycs)
                       (map [push _ used-ps] using-ps))
                     (push car.cycs cycs)))
               (eratos4-thing eratos4
                              b blen
                              1 0 0 ;linked_list, with ignored arguments
                              (byteses->array+bytes cycs))))
;           (= ups used-ps nubs (subbytes b 0))
           (each p used-ps (set-bit b p 1))
           (eratos4-thing eratos4
                          b blen
                          7 ;finish with btr4
                          (+ 1 (best > used-ps));starting beyond last prime used; it exceeds 5
                          0 (make-bytes 1)))
         b))))
  
  (def pretty-dumb-prime-bits (n)
    (when (> n 0)
     (= n (bit-and (+ (+ n 1) 63) -64)) ;bump up to have 0-n not 0-n-1
     (let blen (div n 8)
       (let b (make-bytes blen 255)
         (set-bit b 0 0)
         (set-bit b 1 0)
         (eratos4-thing eratos4
                        b blen
                        3 2
                        0 make-bytes.1)
         b))))
                        
 
 )


(def stirling (n)
  (* (sqrt:* tau n) (expt (/ n euler) n)))
;unfortunately that is only useful on numbers whose factorials are too big to fit in floats

(def stirling-log (n (o base euler))
  (+ (* 1/2 (+ (log n euler) (log tau euler)))
     (* n (- (log n euler) 1))))

;OH MY GAAAAAAAAWD WE ARE REWRITING SOME BASIC PROCEDURES AND MACROS
;TO FIT A CERTAIN SPECIFICATION
;E.G. (let u (n-of 10 (amb 1 2)) (require (is u.2 2)) u) SHOULD TERMINATE

(= n-of (macro (n expr)
          (w/uniq (gn ghead gtail gf gu)
            `(with (,gn ,n)
               (if (is ,gn 0)
                   nil
                   (let ,ghead (cons ,expr nil)
                     ((rfn ,gf (,gn ,gtail)
                        (if (is ,gn 0)
                            ,ghead
                            (let ,gu (cons ,expr nil)
                              (scdr ,gtail ,gu)
                              (,gf (- ,gn 1) ,gu))))
                      (- ,gn 1) ,ghead)))))))

;FUCKING IDEMPOTENT, THAT IS
;Amusingly, tail recursion and mutation of a variable should be equivalent
;for dicking.
;UNLESS THERE ARE TWO CONTINUATIONS SAVED OR SMTHG
;... actually... jesus...

;for the moment, writing in slightly terrible way where I begin with len
;... this obviously only works with associative things
(def binary-reduce (f xs)
  (if no.xs
      (f)
      (xloop (xs xs n len.xs)
        (if (is n 1)
            car.xs
            (let a (ash n -1)
              (f (next (take a xs) a)
                 (next (drop a xs) (- n a))))))))


;the wonderful idea:
;1. Given integer coeffs, must factor into integer coeffs if rational.
;2. Given some values... if g(x), an integer poly divides f(x), an integer poly,
;   then g(c), an integer, will divide f(c), an integer, for all integers c.
;3. If there is a nontrivial factor, then it has degree floor(deg(f)/2).
;   Call that n.
;4. We plug in n+1 values of c in f(c).
;   g(x) must evaluate to a factor of f(c) in all those cases.
;   I.e. there must be a set {this factor of f(this c), ...} that
;   g(x) evaluates to at the c's. So, try all sets.
;... so. if I always do [a a+1 ... b], then I can use
;differences and crap to get g. however, otherwise, should lagrange-interpolate.
(delay-def kronecker-factor-poly (p)
  (withs (g (/ (apply gcd (map numer p))
               (apply lcm (map denom p)))
          p (map [/ _ g] p))
    ;range: from ceiling(-n/2) to floor(n/2).
    ;n=0 => 0,0
    ;n=1 => 0,0... ok...
    ;range: from -floor(n/2) to ceiling(n/2).
    ;n=0 => 0,0
    ;n=1 => 0,1
    ;n=2 => 1,1
    ;ok.
    (let n (ash degree.p -1) ;factorz
      (with (a (-:ash n -1) b (ash inc.n -1))
        (with (rng (range a b) vals (mapn [eval-poly p _] a b))
          (aif (pos 0 vals)
               (list -:rng.it 1)
               (find [and (> degree._ 0) (divides-poly _ p)]
                     (map [lagrange-interpolate-poly
                           (map list rng _)]
                          (all-choices*
                           list
                           (cons (divisors:abs car.vals)
                                     (map [cons -1 divisors:abs._]
                                          cdr.vals)))))))))))
    
        
(def kfp (x)
  (kronecker-factor-poly x))

(def divides-poly (d p)
  (all 0 (remainder-poly p d)))

(def l-i-p (xs)
  (lagrange-interpolate-poly xs))

;how does this work with one point?
;two points?
;... fuck, I think I'll special-case one point.

;xs is ((x f(x)) ...)

;so. f(a)=A,f(b)=B,f(c)=C.
;poly = ___(x-a)(x-b) + ___(x-b)(x-c) + ___(x-c)(x-a).
;     C/(c-a)(c-b)    A/(a-b)(a-c)    B/(b-c)(b-a)
(delay-def lagrange-interpolate-poly (xs)
  (if no:cdr.xs
      (list xs.0.1)
      (reduce add-poly
              (mapn (fn (n)
                      (let (xn xnv) xs.n
                        (let u (/ xnv (reduce * (map [- xn car._] (but-nth n xs))))
                          (map [* _ u] (binary-reduce mul-poly
                                                      (map [list -:car._ 1]
                                                           (but-nth n xs)))))))
                    0 dec:len.xs))))

(= mod-expt ($:lambda (a n m)
              (let loop ((a a) (n n) (tt 1))
                (cond ((odd? n) (loop a (sub1 n) (modulo (* a tt) m)))
                      ((zero? n) tt)
                      (else (loop (modulo (* a a) m) (arithmetic-shift n -1) tt))))))

;see prev. definition of "with"
(= withs (macro (bind . rest)
           (if no.bind
               `(do ,@rest)
               acons.bind
               (if acons:cdr.bind
                   `(let ,car.bind ,cadr.bind
                      (withs ,cddr.bind
                        ,@rest))
                   (err "withs: What?" bind))
               ;type 2: (withs x (dick) y ass (blarg) (blarg) (blarg))
               ;(roughly)
               (let xs (cons bind rest)
                 (let n (or (pos (compose no (andf [isa _ 'sym] no:ssyntax) car)
                                 (tuples 2 xs))
                            (div len.xs 2))
                   `(withs ,(take (* 2 n) xs)
                      ,@(drop (* 2 n) xs)))))))

(def proper-list (xs)
  (or no.xs
      (and acons.xs
           (proper-list cdr.xs))))

(def sqr (x) (* x x)) ;baker; good name

(def meh1 (xs)
  (let n 0
    (each x xs
      (++ n x))
    n))

;no longer duplicates body 3 times
;...
;oh my god.
;...
;hmm...
;in theory we could statically eliminate some cases
;when mapping a table, where the number of arguments is
;not compatible with a "length 2 list".
;also, if s.i is only for strings, we can be sure
;that that won't happen.
;mmmph, whatever.

;...
;Let us avoid O(n) consing in normal usage.
;Without relying on being able to parse arglists.
;Hmm...
;((fn a b ...) c ...) = (let a (list c ...) b ...)
;(let a b c ...) = ((fn (a) c ...) b)
;...
;Welp. Time to screw something over.
;Currently destructuring is never non-consing, so...

;Fuck, that didn't handle (each (x . y) ...) before ('cause I fucked it up).
;Now...

(= each (macro (var expr . body) ;oh boy
  (w/uniq (gseq gf gv gf1 gargs gf2)
    (let two (and acons.var
                  (acons cdr.var)
                  (no:cdr cdr.var))
      ((if no.two
           (fn (bd) `(let ,gf1 (fn (,var) ,@body)
                       ,bd))
           (fn (bd) `(let ,gf2 (fn ,var ,@body)
                       (let ,gf1 (fn (,gargs) (apply ,gf2 ,gargs))
                         ,bd))))
       
       `(let ,gseq ,expr
          (if (alist ,gseq)
              ((rfn ,gf (,gv)
                 (when (acons ,gv)
                   (,gf1 (car ,gv))
                   (,gf (cdr ,gv))))
               ,gseq)
              (isa ,gseq 'table)
              (maptable ,(if two gf2 `(fn ,gargs (,gf1 ,gargs)))
                        ,gseq)
              (for ,gv 0 (- (len ,gseq) 1)
                (,gf1 (,gseq ,gv))))))))))


(def meh2 (xs)
  (let n 0
    (each x xs
      (++ n x))
    n))

(def perf-stats ((o n 7))
  ($ (let ((u (make-vector n)))
       (vector-set-performance-stats! u)
       u)))

; assumes 64-bit float, no denormals or wtvr
(def float->rat (x) 
  (* (if (bit-test x 63) -1 1)
     (expt 2 (+ -1023 (bit-and (dec:ash 1 11) (ash x -52))))
     (+ 1 (/ (bit-and x (dec:ash 1 52)) (expt 2 52)))))

(def mat-scale (m x)
  (deep-map [* _ x] m))

(def mat-sub (x y)
  (mat-add x (mat-scale y -1)))

(def cons? (x) (acons x))
(def atom? (x) (no:acons x))
(def string? (x) (isa x 'string))
(def table? (x) (isa x 'table))
(def sym? (x) (isa x 'sym))
(def no? (x) (no x))


(mac casenlet (var expr . args)
  `(let ,var ,expr
     ,(xloop (args args)
        (if no:cdr.args
            car.args
            `(if (or ,@(map [list 'is var `',_]
                            (if acons:car.args
                                car.args
                                list:car.args)))
                 ,cadr.args
                 ,next:cddr.args)))))

(mac casen (expr . args)
  `(casenlet ,(uniq) ,expr ,@args))

;now, case could be like casen, because (is x '(blah blah)) is almost
;always false.
;however, for the moment, I shall hold off on that.


;bear in mind that the following thing...
;if you tell it to make keystroke h, and you hold down ctrl as it does so,
;it'll register as ctrl-h. lolz. mmm.

(def applescript-keystroke (x (o dicks nil))
  (system:string 
   "osascript -e 'tell application \"System Events\" to keystroke \""
   x "\"" (if dicks (tostring 
                     (pr " using {")
                     (between d dicks (pr ",") (pr d " down"))
                     (pr "}")))
   "'"))

(= key-modifier-names
   (obj shf 'shift
        cmd 'command
        opt 'option
        ctrl 'control
        ctl 'control))

(def listify (x)
  (if acons.x x no.x x list.x))

(mac keystroke (k (o mods nil))
  `(applescript-keystroke
    ',(if (or (isa k 'string)
              (is 1 len:string.k))
          k
          (case k
            tab "\\t"
            k))
    ',(map [or key-modifier-names._ _] listify.mods)))
;^ it also works to say "keystroke tab" rather than "keystroke "tab""...
;meanwhile, the issue is what happens if the user is pressing modifier keys.
;that screws things up.
;now...

;incidentally, one can also say "key code nn" in place of "keystroke "x"".

;As someone amazing on the internet sez:
;http://apple.stackexchange.com/questions/36943/how-do-i-automate-a-key-press-in-applescript
;The key codes are defined in:
;/System/Library/Frameworks/Carbon.framework/Frameworks/HIToolbox.framework/Headers/Events.h
  
;lolololol, for getting out of a terrible situation
(def UNPRESS_SHIFT ()
  (system "osascript -e 'tell application \"System Events\" to key up shift'"))
(= KEY_UP_SHIFT UNPRESS_SHIFT)


(def tuples-plus (n xs)
  (let (x y) (split rev.xs (mod len.xs n))
    (list (tuples n rev.y) rev.x)))

;same as case except you eval the test-exprs
(mac vcase (expr . clauses)
  (let (pairs default) (tuples-plus 2 clauses)
    (w/uniq gexpr
      `(let ,gexpr ,expr
         (if ,@(mappend (fn ((x y)) `((is ,gexpr ,x) ,y)) pairs)
             ,@default)))))


;this shit shoulda been defined a long time ago
;... and now we translate it from ssx9 syntax, oh well
(def match-expr (g bind val next-clause)
  (if (and acons.bind (is car.bind 'unquote))
      `(let ,cadr.bind ,g
         ,val)
      (match-expr-tail g bind val next-clause)))

;... do we do unquote-splicing too?
;feh, why not
;... 'cause it's kinda hard
;... also it ... wow... huh. interesting.
;...
;...
;semi-enlightenment. allowing (bleh unquote nerf) to treat the unquote specially
;[i.e. not distinguishing between match-expr and match-expr-tail]
;is like unquote-splicing, except this only works at the end of a list.
;allowing full unquote-splicing would involve seriously more sophistication.
;[perhaps not too much more; could probably cons up an FSM]
;meh, screw that for now.
;-- eh, I can do rest args, at least.

;btw, this syntax leaves open more avenues for expansion.
;atm the x in ,x must be a symbol.
;obv. we could do something like ,int?x -> ,(int? x) -> bind x
; and test int? on it.
(def match-expr-tail (g bind val next-clause)
  (if (and acons.bind acons:car.bind (is caar.bind 'unquote-splicing))
      (if no:cdr.bind
          `(let ,cadar.bind ,g
             ,val)
          (err "match is currently not advanced enough to support ,@ except at list-tails" bind))
      acons.bind
      `(if (atom ,g)
           ,next-clause
           ,(w/uniq (gcar gcdr)
              `(let ,gcar (car ,g)
                 ,(match-expr gcar car.bind
                              `(let ,gcdr (cdr ,g)
                                 ,(match-expr-tail gcdr cdr.bind val next-clause))
                              next-clause))))
      `(if (is ,g ',bind)
           ,val
           ,next-clause)))

(mac match (expr . cases)
  (with gx (uniq) gfinal (uniq "df") ;default
    (let (clauses last) (tuples-plus 2 cases)
      (let last-clause `(fn () ,(if last car.last nil)) ;last is a list...
        `(let ,gx ,expr
           (let ,gfinal ,last-clause
             ,(xloop (rcases rev.clauses
                      next-clause `(,gfinal)) ;lel
                (if no.rcases
                    next-clause
                    (next cdr.rcases
                          (let (bind result) car.rcases
                            (w/uniq gfail
                              `(let ,gfail (fn () ,next-clause)
                                 ,(match-expr gx bind result `(,gfail))))))))))))))

(def join1 (xs x)
  (join xs list.x))

(mac match-strict (expr . cases)
  (if (odd len.cases)
      `(match ,expr ,@cases)
      `(match ,expr
         ,@(join1 cases
                 `(err "Failed to match " ',expr
                       "against any of:" ,@(map [list 'quote car._]
                                                (tuples 2 cases)))))))

(= bound? bound)

(def Y (f) (fn args (apply (f (Y f)) args)))

(def ac (x) ($.ac ($.ac-denil x) $.null))

(def num? (x) ($ (if (number? x) 't 'nil)))

(def map-index (f xs)
  (xloop (xs xs ys nil n 0)
    (if no.xs
        rev.ys
        (next cdr.xs (cons (f car.xs n) ys) inc.n))))


;probably final form now
(= sum (case-fn
        (xs) (reduce + xs)
        (f xs) (accumulate + f:car xs 0 cdr no)
        (f a b) (accumulate + f a 0 1+ [> _ b])))

;and this
(= product (case-fn
            (xs) (reduce * xs)
            (f xs) (accumulate * f:car xs 1 cdr no)
            (f a b) (accumulate * f a 1 1+ [> _ b])))

(mac d (x) (no:dpprn definitions*.x)) ;useful

(mac dlet (x val . body)
  `(call/dyn ,x ,val (fn () ,@body)))

;Debugging shit
(= brx-n 0
   brx-table (table))
(mac brx (expr)
  (let (name . rest) expr
    (let u ++.brx-n
      (= brx-table.u expr)
      `(do (prsn ',(symb name u) 'enter)
         (do1 ,expr
              (prsn ',(symb name u) 'ret))))))

(mac dbg (expr)
  (let (name . rest) expr
    (let u ++.brx-n
      (= brx-table.u expr)
      (with args (map [uniq] rest)
        gexpr (uniq)
        `(withs ,gexpr ,expr
           ,@(interleave args rest)
           (prsn ',(symb expr u) ,@args)
           (do1 (,gexpr ,@args)
                (prsn ',(symb expr u) 'ret)))))))

(= bytes-load ($ bytevector-s64-native-ref)
   bytes-store ($ bytevector-s64-native-set!))

(defmemo handle-and-dlsym ()
  (let u make-bytes.16
    ((get-ffi-obj "install_handle_and_dlsym"
                  asm-lib
                  (cprocedure '(bytes)))
     u)
    u))
