; The previous experience, with compiling s-reduce (I think),
; was somewhat traumatic, or at least it leaves an intimidating
; memory.  Therefore, we will use a smaller example.

(mac plus args
  `(+ ,@args))

(def nerf (x)
  (plus x (plus 2 3)))

;At this point,
;plus = (macro (closure nil args `(+ ,@args))
;and nerf = (closure nil (x) (plus x (plus 2 3))).

;Now...
;We shall pseudo-compile nerf.

(fn (x) 
  (plus x (plus 2 3)))

;For completeness...
;Oh boy, we will be complete.
;Now.
;I guess we'll sort of be abstractly compiling...
;Aha, yes.
;This might be "inverse eta-conversion" or whatever.
;Anyway, that is the appropriate thing to do.

(fn (x)
  (nerf x))

;Well, not exactly.
;The value of nerf does have to be substituted in there.
;If nerf is called, and nerf gets redefined just before
;any computation happens, it's still gonna be the orig.
;value of nerf that made a difference.

(fn (x)
  ((closure nil (x) (plus x (plus 2 3)))
   x))

;Now.
;... hmm.
;Is the abstract thing, the result of "inverse eta-conv",
;actually a function of an "args" argument?
;No.  We must remember Appel's lessons.  (Though he sidestepped
; this particular one because ML is ML.)
;nerf will be bound to, essentially,
;(fn args (let (x) args (nerf-code x)))
;Actually, I should do that.
;--or not.
;I should do something kind of parallel and equivalent to that.
;... Eh, closure.
;p[n] is private.

;we are compiling the closure itself,
;so there is no check for whether nerf = p0.

(with p0 (closure nil (x) (plus x (plus 2 3)))
  (fn (x) (p0 x)))

;now...
;ueval, I guess.
;do I create a fake lexenv?
;... maybe a fake eval.
;neh...
;try to avoid.

(fn (x) (eval '('(closure nil (x) (plus x (plus 2 3)))
                x)))

;now. quoted is ... ... oh my god.  jesus christ.
;that expression itself.
;the '('(...) x) expression, must check on that.
;that, or dick.
;do not like constructing spurious expressions.
;(do like constructing necessary and inevitable expressions.)
;... you can't say what (apply <macro> args) should be.
;so this should probably go from "apply".

;I guess we could do it like this.

(fn (x)
  (apply-1 '(closure nil (x) (plus x (plus 2 3)))
           x))
;Or more like funcall.  That works.  All right.

(fn (x)
  (funcall '(closure nil (x) (plus x (plus 2 3)))
           x))

;Now.

(with p0 '(closure nil (x) (plus x (plus 2 3)))
  (fn (x)
    (funcall p0 x)))

;No quoted dicks (in the expression).  I like it.

(with p0 '(closure nil (x) (plus x (plus 2 3)))
  (fn (x)
    (let dumb-arglist (list x)
      (apply p0 dumb-arglist))))

;Now we can do this stuff.
;car.p0 is indeed 'closure.
;(or p0 would have type 'closure in a full impl.)
;actually, I'm elevating that to the status of "true".
;no proper way to mutate the type of an object.

(with p0 '(closure nil (x) (plus x (plus 2 3)))
  (fn (x)
    (let dumb-arglist (list x)
      (let (env arglist . bodexprs) cdr.p0
        (apply-loop (join-envs env arglist dumb-arglist)
                    bodexprs)))))

;going to make this agnostic about how closures are represented.
;...
;ok.

(with p0 '(closure nil (x) (plus x (plus 2 3)))
  (fn (x)
    (let dumb-arglist (list x)
      (with env closure-env.p0
        arglist closure-arglist.p0
        bodexprs closure-body.p0
        (apply-loop (join-envs env arglist dumb-arglist)
                    bodexprs)))))

;now, I think we can cache _this_ stuff.
;I don't think it really makes sense for, e.g., the env of
;a closure to be replaced with another env. (ok it kinda does but mmm)
;let's just say that.
;so we don't need to compare.
  
(withs p0 '(closure nil (x) (plus x (plus 2 3)))
  p1 closure-env.p0
  p2 closure-arglist.p0
  p3 closure-body.p0
  (fn (x)
    (let dumb-arglist (list x)
      (with env p1
        arglist p2
        bodexprs p3
        (apply-loop (join-envs env arglist dumb-arglist)
                    bodexprs)))))

;hmm... quoted crap...
;...
;ok, the way to handle this stuff is to create more bindings
;that reach deeper and then to let the old bindings drop out.
;(e.g. here)
;hmm, but... hmm...
;for my representation...
;eh.
;yes, this is useful.

(withs p0 
  p1 'nil
  p2 '(x)
  p3 '((plus x (plus 2 3)))
  p0 `(closure ,p1 ,p2 ,@p3)
  (fn (x)
    (let dumb-arglist (list x)
      (with env p1
        arglist p2
        bodexprs p3
        (apply-loop (join-envs env arglist dumb-arglist)
                    bodexprs)))))

;and the nice thing is that this appears to demonstrate that I could
;inline any interpreter in the world and, as long as it did
;side effects in the right order and didn't do any unnecessary ones,
;then, if I could eliminate all crap, the result should be the same.
;... hmm... the representation of the env...
;we will probably end up assuming, later on, that the structure of
;envs (as opposed to their contents) is never mutated.

(withs p0 
  p1 'nil
  p2 '(x)
  p3 '((plus x (plus 2 3)))
  p0 `(closure ,p1 ,p2 ,@p3)
  (fn (x)
    (let dumb-arglist (list x)
      (with env p1
        arglist p2
        bodexprs p3
        (let teh-env (join-envs env arglist dumb-arglist)
          (apply-loop teh-env
                      bodexprs))))))

;now we can inline that crap...
;... ok, let's just write this as though the struc. of envs
;can be mutated.
;and whatever other crap.
;oh god.
;there will be many lookups within envs...
;ok, fuck.
;just screw that.

(withs p0 
  p1 'nil
  p2 '(x)
  p3 '((plus x (plus 2 3)))
  p0 `(closure ,p1 ,p2 ,@p3)
  (fn (x)
    (let dumb-arglist (list x)
      (with env p1
        arglist p2
        bodexprs p3
        (let teh-env (list (list 'x x))
          (apply-loop teh-env
                      bodexprs))))))

;there we go. laziness solves everything.
;and I'm not talking about the evaluation order.
;now we can drop some things.

(withs
  p3 '((plus x (plus 2 3)))
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let dumb-arglist (list x)
      (with
        bodexprs p3
        (let teh-env (list (list 'x x))
          (apply-loop teh-env
                      bodexprs))))))

;sigh... ho-k.
;no.p3 will be false always.
;no:cdr.p3 may be false if mutation.
;k.
;um...
;my intended strategy was to just have "physically call p0"
;as a backup.

;(withs
;  p4 'nil
;  p3 `((plus x (plus 2 3)) ,@p4) ;methinks (a . ,b) doesn't work well,
;  p0 `(closure nil (x) ,@p3)     ;having investigated it (this may not either)
;  (fn (x)
;    (let dumb-arglist (list x)
;      (with
;        bodexprs p3
;        (let teh-env (list (list 'x x))
;          (if (is cdr.p3 p4)
;              (eval-lex car.p3 
;          (apply-loop teh-env
;                      bodexprs))))))

;Hey, I'm jumping the gun a little.  Here's what should really happen.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5)
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let dumb-arglist (list x)
      (with
        bodexprs p3
        (let teh-env (list (list 'x x))
          (apply-loop teh-env
                      bodexprs))))))

;and then, like, ... I guess we should be direct

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5)
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (apply-loop teh-env
                  p3))))

;hmm, I guess that in a real situation,
;we may do some side effects and then discover that
;shit has been changed on us.
;in that case, we will actually have to fall back on
;the intermediate functions like apply-loop.

;... so.
;ok, I'll illustrate by inlining body.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (if no.p3
          nil
          no:cdr.p3
          (eval-lex car.p3 teh-env)
          (do (eval-lex car.p3 teh-env)
            (apply-loop teh-env cdr.p3))))))

;and so.
;it is known statically that p3 is not nil.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (if nil
          nil
          no:cdr.p3
          (eval-lex car.p3 teh-env)
          (do (eval-lex car.p3 teh-env)
            (apply-loop teh-env cdr.p3))))))

;which reduces the if.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (if no:cdr.p3
          (eval-lex car.p3 teh-env)
          (do (eval-lex car.p3 teh-env)
            (apply-loop teh-env cdr.p3))))))

;now what we shall do is this.  ("no" and "cdr", being code of the interp.,
; are known)

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (if (is cdr.p3 p5)
          (if no.p5
              (eval-lex car.p3 teh-env)
              (do (eval-lex car.p3 teh-env)
                (apply-loop teh-env cdr.p3)))
          (if no:cdr.p3
              (eval-lex car.p3 teh-env)
              (do (eval-lex car.p3 teh-env)
                (apply-loop teh-env cdr.p3)))))))

;hmmph.  what I really need is to be able to say "fuck, just jump
; back up to the top of apply-loop". this will be justified when
;no side effects have occurred between here and where we jump back to.
;(this may include, um... side effects performed by someone else...)
;in that case, it's best when this eval crap is broken into segments
;that perform just a little stuff.
;(... so little it only checks one thing)
;well, oh well.

;so now "no.p5" is known.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (if (is cdr.p3 p5)
          (if t
              (eval-lex car.p3 teh-env)
              (do (eval-lex car.p3 teh-env)
                (apply-loop teh-env cdr.p3)))
          (if no:cdr.p3
              (eval-lex car.p3 teh-env)
              (do (eval-lex car.p3 teh-env)
                (apply-loop teh-env cdr.p3)))))))

;and. [btw in more complicated code, I should prob. have a way to sep.
; the interpreter's code from the user code]

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (if (is cdr.p3 p5)
          (eval-lex car.p3 teh-env)
          (if no:cdr.p3
              (eval-lex car.p3 teh-env)
              (do (eval-lex car.p3 teh-env)
                (apply-loop teh-env cdr.p3)))))))

;ok, now...

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (eval-lex p4 teh-env)
              (eval-lex car.p3 teh-env))
          (if no:cdr.p3
              (eval-lex car.p3 teh-env)
              (do (eval-lex car.p3 teh-env)
                (apply-loop teh-env cdr.p3)))))))

;also a little bit of cleanup...

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (list (list 'x x))
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (eval-lex p4 teh-env)
              (eval-lex car.p3 teh-env))
          no:cdr.p3
          (eval-lex car.p3 teh-env)
          (do (eval-lex car.p3 teh-env)
            (apply-loop teh-env cdr.p3))))))

;ok, now.
;we'll deal with some env crap... so use tables.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (eval-lex p4 teh-env)
              (eval-lex car.p3 teh-env))
          no:cdr.p3
          (eval-lex car.p3 teh-env)
          (do (eval-lex car.p3 teh-env)
            (apply-loop teh-env cdr.p3))))))

;hmm.  y'know what?  I can go back and clean things up a little.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (apply-loop teh-env p3))))

;now we could just be like this.
;... this is a little bit sophisticated,
;but I could break up uapply-loop
;and get the same result here.
;... um.  ok, I'll do that.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (apply-loop2 teh-env p3))))

;and now.
;... what I _really_ need are a bunch of procedures that do not reach into
;their arguments to make decisions.
;e.g. make an extra argument to uapply-loop2 that is cdr.exprs.
;feh.
;anyway...
;... ok, doing that now.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (apply-loop2 p5 teh-env p3)
          (apply-loop2 cdr.p3 teh-env p3)))))

;kk, now...

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if no.p5
              (eval-lex car.p3 teh-env)
              (do (eval car.p3 teh-env)
                (apply-loop teh-env cdr.p3)))
          (apply-loop2 cdr.p3 teh-env p3)))))

;I suppose I could have information stored somewhere describing exac. what
;you need to inline each function profitably.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if t
              (eval-lex car.p3 teh-env)
              (do (eval car.p3 teh-env)
                (apply-loop teh-env cdr.p3)))
          (apply-loop2 cdr.p3 teh-env p3)))))

;Mmm.

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (eval-lex car.p3 teh-env)
          (apply-loop2 cdr.p3 teh-env p3)))))

;Ahhh...

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (eval-lex p4 teh-env)
              (eval-lex car.p3 teh-env))
          (apply-loop2 cdr.p3 teh-env p3)))))

;Now...
;we eval-lex p4.
;p4 is not int or sym, and is not special object.
;(that should not be rep. as a cons-like thing)
;... hmm... I'm going to go against the definition, which asks "alist",
;and instead just ask "acons".  bwahahaha.
;(cdr could be a table, oh man...)

(withs
  p4 '(plus x (plus 2 3))
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (let (f . xs) p4
                (let u (ueval f teh-env)
                  (ueval-call u xs teh-env)))
              (eval-lex car.p3 teh-env))
          (apply-loop2 cdr.p3 teh-env p3)))))

;now we dick

(withs
  p6 'plus
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (if (and (is car.p4 p6)
                       (is cdr.p4 p7))
                  (let u (ueval p6 teh-env)
                    (ueval-call u p7 teh-env)))
              (let (f . xs) p4
                (let u (ueval f teh-env)
                  (ueval-call u xs teh-env)))
              (eval-lex car.p3 teh-env))
          (apply-loop2 cdr.p3 teh-env p3)))))

;jesus christ
;well, at least...

(withs
  p6 'plus
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (if (and (is car.p4 p6)
                       (is cdr.p4 p7))
                  (let u (symbol-value 'plus)
                    (ueval-call u p7 teh-env)))
              (let (f . xs) p4
                (let u (ueval f teh-env)
                  (ueval-call u xs teh-env)))
              (eval-lex car.p3 teh-env))
          (apply-loop2 cdr.p3 teh-env p3)))))

;and now we do this fuckin' crap
;(btw things actually don't need to be hard; all this "if" crap
; so far is collapsible into a big "and" and then a call to plain
; eval)

(withs
  p8 '(macro (closure nil (fn args `(+ ,@args))))
  p6 'plus
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (if (and (is car.p4 p6)
                       (is cdr.p4 p7))
                  (if (is (symbol-value 'plus) p8)
                      (ueval-call p8 p7 teh-env)
                      (let u (symbol-value 'plus)
                        (ueval-call u p7 teh-env))))
              (let (f . xs) p4
                (let u (ueval f teh-env)
                  (ueval-call u xs teh-env)))
              (eval-lex car.p3 teh-env))
          (apply-loop2 cdr.p3 teh-env p3)))))

;oh boy...

(withs
  p9 '(closure nil (fn args `(+ ,@args)))
  p8 '(macro ,p9)
  p6 'plus
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (is cdr.p3 p5)
          (if (is car.p3 p4)
              (if (and (is car.p4 p6)
                       (is cdr.p4 p7))
                  (if (is (symbol-value 'plus) p8)
                      (let u (apply p9 p7)
                        (eval-lex u teh-env))
                      (let u (symbol-value 'plus)
                        (eval-call u p7 teh-env))))
              (let (f . xs) p4
                (let u (eval-lex f teh-env)
                  (eval-call u xs teh-env)))
              (eval-lex car.p3 teh-env))
          (apply-loop2 cdr.p3 teh-env p3)))))

;going to dick now

(withs
  p9 '(closure nil (fn args `(+ ,@args)))
  p8 '(macro ,p9)
  p6 'plus
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let teh-env (obj x x)
      (if (and (is cdr.p3 p5)
               (is car.p3 p4)
               (is car.p4 p6)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8))
          (let u (apply p9 p7)
            (eval-lex u teh-env))
          (apply-loop2 cdr.p3 teh-env p3)))))

;sigh, great.
;we'll get more ands like that if they are separated by a side effect.
;k, now, um...

(withs
  p9 '(closure nil (fn args `(+ ,@args)))
  p8 '(macro ,p9)
  p6 'plus
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 p5)
               (is car.p3 p4)
               (is car.p4 p6)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8))
          (let u (apply-loop (join-envs closure-env.p9
                                        closure-arglist.p9
                                        p7)
                             closure-body.p9)
            (eval-lex u ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;mmm...
;hmm, looks like I forgot my closure representation exactly

(withs
  p10 'nil
  p11 'args
  p12 '(`(+ ,@args))
  p9 '(closure ,p10 ,p11 ,@p11)
  p8 '(macro ,p9)
  p6 'plus
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 p5)
               (is car.p3 p4)
               (is car.p4 p6)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8))
          (let u (apply-loop (join-envs closure-env.p9
                                        closure-arglist.p9
                                        p7)
                             closure-body.p9)
            (eval-lex u ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and now we sub. the immutable parts directly

(withs
  p10 'nil
  p11 'args
  p12 '(`(+ ,@args))
  p9 '(closure ,p10 ,p11 ,@p11)
  p8 '(macro ,p9)
  p6 'plus
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p5 'nil
  p3 `(,p4 ,@p5) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 p5)
               (is car.p3 p4)
               (is car.p4 p6)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8))
          (let u (apply-loop (join-envs 'nil
                                        'args
                                        p7)
                             closure-body.p9)
            (eval-lex u ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh, I guess I also forgot something else.
;extreme stupidity.
;--wait no, we are applying a macro.
;(thought I forgot (map [eval _ env] xs))
;k, so, now...
;sigh... let us clean up some things.
;symbols don't need to be var-bound.

(withs
  p12 '(`(+ ,@args))
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(,p6 ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8))
          (let u (apply-loop (join-envs 'nil
                                        'args
                                        p7)
                             p12)
            (eval-lex u ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;kk now

(withs
  p12 '(`(+ ,@args))
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8))
          (let u (apply-loop (obj args p7 parent nil) ;heh heh
                             p12)
            (eval-lex u ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;nerf nerf

(withs
  p12 '(`(+ ,@args))
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8))
          (let ev2 (obj args p7) ;heh heh
            (let u (apply-loop ev2 p12)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;this approaches niceness
;now we inline apply-loop.
;or prepare to do so.
;knowing what it wants.
;the cdr of p12.
;hmm... let's try to skip the step of "if"-crap
;and add it directly to the and-expr.
;... skip also the step of binding p14 to 'nil
;and dicking. (we will skip the var p14, though)

(withs
  p13 '`(+ ,@args)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil))
          (let ev2 (obj args p7) ;heh heh
            (let u (apply-loop2 'nil ev2 p12)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;um, kk, then...

(withs
  p13 '`(+ ,@args)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil))
          (let ev2 (obj args p7) ;heh heh
            (let u (eval-lex car.p12 ev2)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;separated out the recognition of car.p12.

(withs
  p13 '`(+ ,@args)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13))
          (let ev2 (obj args p7)
            (let u (eval-lex p13 ev2)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;hoh boy...

(withs
  p15 'quasiquote
  p16 '((+ ,@args))
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13))
          (let ev2 (obj args p7)
            (let u (eval-lex p13 ev2)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and

(withs
  p15 'quasiquote
  p16 '((+ ,@args))
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13))
          (let ev2 (obj args p7)
            (let u (let (f . xs) p13
                     (let u (eval-lex f ev2)
                       (eval-call u xs ev2)))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and

(withs
  p15 'quasiquote
  p16 '((+ ,@args))
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16))
          (let ev2 (obj args p7)
            (let u (let u (eval-lex 'quasiquote ev2)
                     (eval-call u p16 ev2))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh boy.  and...

(withs
  p16 '((+ ,@args))
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object))
          (let ev2 (obj args p7)
            (let u (let u qq-object
                     (eval-call u p16 ev2))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and.

(withs
  p16 '((+ ,@args))
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object))
          (let ev2 (obj args p7)
            (let u (eval-call qq-object p16 ev2)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and

(withs
  p16 '((+ ,@args))
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object))
          (let ev2 (obj args p7)
            (let u (eval-qq (car p16) 1 ev2)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and

(withs
  p17 '(+ ,@args)
  p18 'nil
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object))
          (let ev2 (obj args p7)
            (let u (eval-qq (car p16) 1 ev2)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;

(withs
  p17 '(+ ,@args)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17))
          (let ev2 (obj args p7)
            (let u (eval-qq p17 1 ev2)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;jez' mu'fu' chriz'
;I have the wrong music going
;that's better

(withs
  p19 '+
  p20 '(,@args)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17))
          (let ev2 (obj args p7)
            (let u (eval-qq p17 1 ev2)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh man, we finally get a nontrivial expression.

(withs
  p20 '(,@args)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20))
          (let ev2 (obj args p7)
            (let u (cons (eval-qq '+ 1 ev2)
                         (eval-qq-tail p20 1 ev2))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh man
;prawgress
;desugar p20 and eval-qq '+

(withs
  p20 '((uq-splicing args))
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (eval-qq-tail p20 1 ev2))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;next...

(withs
  p21 '(uq-splicing args)
  p22 'nil
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (eval-qq-tail p20 1 ev2))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;the code for eval-qq-tail will end up inspecting car.p20
;as well as caar.p20.
;I could decompose that, but fuck that.

(withs
  p22 'uq-splicing
  p23 '(args)
  p21 `(,p22 ,@p23)
  p22 'nil
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (eval-qq-tail p20 1 ev2))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;ok, now.
;gahd even more
;I can imagine, at least,
;that eval-qq-tail is written to only
;take the same car/cdr once.
;... hey, I can break this up a little, at least.

(withs
  p24 'args
  p25 'nil
  p22 'uq-splicing
  p23 `(,p24 ,@p25)
  p21 `(,p22 ,@p23)
  p22 'nil
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (join (eval-lex cadar.p20 ev2)
                               (eval-qq-tail cdr.p20)))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then

(withs
  p24 'args
  p25 'nil
  p22 'uq-splicing
  p23 `(,p24 ,@p25)
  p21 `(,p22 ,@p23)
  p22 'nil
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (join (eval-lex 'args ev2)
                               (eval-qq-tail 'nil 1 ev2)))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and oh man I can drop some things...

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (join (eval-lex 'args ev2)
                               (eval-qq-tail 'nil 1 ev2)))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now, due to ev. order, I must do the eval-lex before the eval-qq-tail.
;this would be obvious if I turned it into cps.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (let dick (eval-lex 'args ev2)
                           (join dick
                                 (eval-qq-tail 'nil 1 ev2))))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;so now.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (let dick (lookup 'args ev2)
                           (join dick
                                 (eval-qq-tail 'nil 1 ev2))))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and now dick.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (let dick p7
                           (join dick
                                 (eval-qq-tail 'nil 1 ev2))))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and undick!

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (join p7
                                 (eval-qq-tail 'nil 1 ev2)))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and now eval-qq-tail ... atom.xs -> xs.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let ev2 (obj args p7)
            (let u (cons '+
                         (join p7
                               'nil))
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;I shall optimize (join x 'nil) to x.  The interpreter would know
;its own join, so that should be doable.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let ev2 (obj args p7)
            (let u (cons '+ p7)
              (eval-lex u ev1)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;And OH MY GOD ev2 can now be dropped.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let u (cons '+ p7)
              (eval-lex u ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;Ok, now.  We are finally ready to start optimizing dicks.
;Um, to make optimizations about a structure that has just
;been constructed.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let u (cons '+ p7)
            (let (f . xs) u
              (let u2 (eval-lex f ev1)
                (eval-call u2 xs ev1))))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh man

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let u (cons '+ p7)
            (with f '+ xs p7
              (let u2 (eval-lex f ev1)
                (eval-call u2 xs ev1))))
          (apply-loop2 cdr.p3 ev1 p3)))))

;subst further

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let u (cons '+ p7)
            (with f '+ xs p7
              (let u2 (eval-lex '+ ev1)
                (eval-call u2 p7 ev1))))
          (apply-loop2 cdr.p3 ev1 p3)))))

;drop

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let u2 (eval-lex '+ ev1)
            (eval-call u2 p7 ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (let u2 +-function
            (eval-call u2 p7 ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh man; subst and drop u2

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (eval-call +-function p7 ev1)
          (apply-loop2 cdr.p3 ev1 p3)))))

;now we're like oh my god

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (apply +-function (map [eval-lex _ ev1] p7))
          (apply-loop2 cdr.p3 ev1 p3)))))

;aww, this is kind of annoying now...
;let us introduce an auxiliary func. so it is easy to inline.

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (apply +-function (map-eval p7 ev1))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now...

(withs ;did p25
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 '(x (plus 2 3))
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (let reses (map-eval p7 ev1)
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;

(withs ;did p25
  p26 'x
  p27 '((plus 2 3))
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (let reses (map-eval p7 ev1)
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;aw fuck...

(withs ;did p25
  p26 'x
  p27 '((plus 2 3))
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (let reses (cons (eval-lex car.p7 ev1)
                           (map-eval cdr.p7 ev1))
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;hoo boy...
;note that we'll ev. the cdr way after the car.

(withs ;did p25
  p26 'x
  p27 '((plus 2 3))
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x))
          (let reses (cons (eval-lex 'x ev1)
                           (map-eval cdr.p7 ev1))
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;or maybe not too much after

(withs ;did p25
  p26 'x
  p27 '((plus 2 3))
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x))
          (let reses (cons (lookup 'x ev1)
                           (map-eval cdr.p7 ev1))
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;mmm

(withs ;did p25
  p26 'x
  p27 '((plus 2 3))
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x))
          (let reses (cons x
                           (map-eval cdr.p7 ev1))
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now

(withs
    p27 '((plus 2 3))
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27))
          (let reses (cons x
                           (map-eval p27 ev1))
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then

(withs
  p27 '((plus 2 3))
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27))
          (let reses (cons x
                           (cons (eval-lex car.p27 ev1)
                                 (map-eval cdr.p27 ev1)))
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;it is _this_ cdr that we'll take a while to eval

(withs
  p28 '(plus 2 3)
  p29 'nil
  p27 `(,p28 ,@p29)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28))
          (let reses (cons x
                           (cons (eval-lex p28 ev1)
                                 (map-eval cdr.p27 ev1)))
            (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh no. no. no. no.
;at least indent nice with anf

(withs
  p28 '(plus 2 3)
  p29 'nil
  p27 `(,p28 ,@p29)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28))
          (let darg (eval-lex p28 ev1)
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;sigh... am I ready for this?  sigh...
;I have done the macroexpansion of 'plus before...
;I am going to intervene again.

(withs
  p28 '(+ 2 3)
  p29 'nil
  p27 `(,p28 ,@p29)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28))
          (let darg (eval-lex p28 ev1)
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;bwahaha. now things are nicer.

(withs
  p28 '(+ 2 3)
  p29 'nil
  p27 `(,p28 ,@p29)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28))
          (let darg (let (f . xs) p28
                      (let u (eval-lex f ev1)
                        (eval-call f xs ev1)))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh man

(withs
  p30 '+
  p31 '(2 3)
  p28 '(+ ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28))
          (let darg (let (f . xs) p28
                      (let u (eval-lex f ev1)
                        (eval-call f xs ev1)))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;you know, actually, I will use "plus".

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28))
          (let darg (let (f . xs) p28
                      (let u (eval-lex f ev1)
                        (eval-call f xs ev1)))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31))
          (let darg (let (f . xs) p28
                      (let u (eval-lex 'plus ev1)
                        (eval-call u p31 ev1)))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31))
          (let darg (let (f . xs) p28
                      (let u (lookup 'plus ev1)
                        (eval-call u p31 ev1)))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)) ;aha!
          (let darg (let (f . xs) p28
                      (let u p8
                        (eval-call u p31 ev1)))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;mmm...

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)) ;aha!
          (let darg (eval-call p8 p31 ev1)
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then teh more... p8 is a macro

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)) ;aha!
          (let darg (eval-lex (apply-mac p8 p31) ev1)
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then get closure

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)) ;aha!
          (let darg (eval-lex (apply p9 p31) ev1)
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh god so much eval

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)) ;aha!
          (let darg (let dick (apply p9 p31)
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now...
;...
;"plus" need do no destructuring on its arguments.
;so that is very convenient.
;it will incur no checks.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p11)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)) ;aha!
          (let darg (let dick (apply-loop (obj parent ev1
                                               args p31)
                                          p11)
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;fuck, there did those referenced things go?
;  p11 'args
;  p12 '(`(+ ,@args))
;  p9 '(closure ,p10 ,p11 ,@p11)

;there we go.
;--oh, I see.
;that thing should really be ,@p12.
;k.
;and, uh, the reference from p9 to p12 need not
;be checked.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)) ;aha!
          (let darg (let dick (apply-loop (obj parent ev1
                                               args p31)
                                          p12)
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;so now.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (apply-loop ev2
                                            p12))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;mmm...

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (apply-loop2 cdr.p12 ev2
                                             p12))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;mmm.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(,p15 ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (eval-lex car.p12 ev2))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then...

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (eval-lex p13 ev2))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and p13 is... goddammit, what is p15.  it is qq.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (let (f . xs) p13
                                  (let u (eval-lex f ev2)
                                    (eval-call u xs ev2))))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;so bad

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (let u (eval-lex 'quasiquote ev2)
                                    (eval-call u xs ev2)))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh jesus
;skipping step

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (let u qq-object
                                  (eval-call u p16 ev2)))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;combining steps...

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (eval-qq 1 p17 ev2))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;save me...

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (cons (eval-qq 1 '+ ev2)
                                      (eval-qq-tail 1 cdr.p17 ev2)))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now dick is dick, and then... combining two steps.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (cons '+
                                      (eval-qq-tail 1 p20 ev2)))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now we must get car.p20, caar.p20

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (cons '+
                                      (join (eval-lex cadr.p21 ev2)
                                            (eval-qq-tail 1 cdr.p20 ev2))))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now we get cadr.p21

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (cons '+
                                      (join (eval-lex 'args ev2)
                                            (eval-qq-tail 1 cdr.p20 ev2))))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then that becomes lookup and then p31.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (cons '+
                                      (join p31
                                            (eval-qq-tail 1 cdr.p20 ev2))))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then we get cdr.p20

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let darg (let dick (let ev2 (obj parent ev1
                                            args p31)
                                (cons '+
                                      (join p31
                                            'nil)))
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now we "join x nil -> x" and drop ev2

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let darg (let dick (cons '+ p31)
                      (eval-lex dick ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh my god
;since dick has been just constructed, we know what its car is

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil))
          (let darg (let dick (cons '+ p31)
                      (let u (eval-lex '+ ev1)
                        (eval-call u p31 ev1)))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh my god we can drop dick now
;but that vertical space will immediately be occupied by a check
;for the value of '+.

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (let darg (let u +-function
                      (eval-call u p31 ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and then we can drop u... and get that eval-call to happen...

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (let darg (apply +-function u (map-eval p31 ev1))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;still can't drop ev1 yet.
;now, we shall dick...
;(oh duh certainly can't)

(withs
  p31 '(2 3)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (let darg (let reses2 (map-eval p31 ev1)
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh man this should be relatively benign

(withs
  p32 '2
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function))
          (let darg (let reses2 (cons (eval-lex car.p31 ev1)
                                      (map-eval cdr.p31 ev1))
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;now we check dick.

(withs
  p32 '2
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2))
          (let darg (let reses2 (cons 2
                                      (map-eval cdr.p31 ev1))
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and.

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33))
          (let darg (let reses2 (cons 2
                                      (map-eval p33 ev1))
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33))
          (let darg (let reses2 (cons 2
                                      (cons (eval-lex car.p33 ev1)
                                            (map-eval cdr.p33 ev1)))
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and now

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3))
          (let darg (let reses2 (cons 2
                                      (cons (eval-lex 3 ev1)
                                            (map-eval cdr.p33 ev1)))
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3))
          (let darg (let reses2 (cons 2
                                      (cons 3
                                            (map-eval cdr.p33 ev1)))
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil))
          (let darg (let reses2 (cons 2
                                      (cons 3
                                            (map-eval 'nil ev1)))
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil))
          (let darg (let reses2 (cons 2
                                      (cons 3
                                            'nil))
                      (apply +-function u reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and now w... why is "apply +-function u"?  wtvr.
;we know how to apply system-functions.

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil))
          (let darg (let reses2 (cons 2
                                      (cons 3
                                            'nil))
                      (apply +-function reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;which we shall shorten in some way.

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil))
          (let darg (let reses2 (cons 2
                                      (cons 3
                                            'nil))
                      (apply +-function 2 cdr.reses2))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;incrementally like this.

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil))
          (let darg (let reses2 (cons 2
                                      (cons 3
                                            'nil))
                      (apply +-function 2 3 'nil))
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then we can drop.

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil))
          (let darg (apply +-function 2 3 'nil)
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;also, reduce.

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil))
          (let darg (+-function 2 3)
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then we can reduce this crap at compile time.

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil))
          (let darg '5
            (let reses (cons x
                             (cons darg
                                   (map-eval cdr.p27 ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;then we have a little more shit to do.

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (let darg '5
            (let reses (cons x
                             (cons darg
                                   (map-eval 'nil ev1)))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh my god

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (let darg '5
            (let reses (cons x
                             (cons darg
                                   'nil))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and sub

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (let darg '5
            (let reses (cons x
                             (cons '5
                                   'nil))
              (apply +-function reses)))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and drop

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (let reses (cons x
                           (cons '5
                                 'nil))
              (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and turn the apply into an apply [one of a system-function]

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (let reses (cons x
                           (cons '5
                                 'nil))
              (apply +-function reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and incrementally insert args

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (let reses (cons x
                           (cons '5
                                 'nil))
              (apply +-function x cdr.reses))
          (apply-loop2 cdr.p3 ev1 p3)))))
;and more
(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (let reses (cons x
                           (cons '5
                                 'nil))
              (apply +-function x '5 cddr.reses))
          (apply-loop2 cdr.p3 ev1 p3)))))

;but that is 'nil

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (let reses (cons x
                           (cons '5
                                 'nil))
              (apply +-function x '5 'nil))
          (apply-loop2 cdr.p3 ev1 p3)))))

;and drop

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (apply +-function x '5 'nil)
          (apply-loop2 cdr.p3 ev1 p3)))))

;and de-nerbify

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (let ev1 (obj x x)
      (if (and (is cdr.p3 'nil)
               (is car.p3 p4)
               (is car.p4 'plus)
               (is cdr.p4 p7)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p7 'x)
               (is cdr.p7 p27)
               (is car.p27 p28)
               (is car.p28 'plus)
               (is cdr.p28 p31)
               (is (symbol-value 'plus) p8)
               (is cdr.p12 'nil)
               (is car.p12 p13)
               (is car.p13 'quasiquote)
               (is cdr.p13 p16)
               (is (symbol-value 'quasiquote) qq-object)
               (is car.p16 p17)
               (is car.p17 '+)
               (is cdr.p17 p20)
               (is car.p20 p21)
               (is car.p21 'unquote-splicing)
               (is cdr.p21 p23)
               (is car.p23 'args)
               (is cdr.p20 'nil)
               (is (symbol-value '+) +-function)
               (is car.p31 '2)
               (is cdr.p31 p33)
               (is car.p33 '3)
               (is cdr.p33 'nil)
               (is cdr.p27 'nil))
          (+-function x '5)
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh, and I suppose this should have been done a hell of a lot earlier,
;but we can move the ev1 binding around...

(withs
  p33 '(3)
  p31 `(2 ,@p33)
  p28 '(plus ,@p31)
  p27 `(,p28)
  p23 '(args)
  p21 `(uq-splicing ,@p23)
  p20 `(,p21)
  p17 `(+ ,@p20)
  p16 `(,p17 ,@p18)
  p13 `(quasiquote ,@p16)
  p12 `(,p13)
  p9 '(closure nil args ,@p12)
  p8 '(macro ,p9)
  p7 `(x ,@p27)
  p4 '(plus ,@p7)
  p3 `(,p4 . nil) ;note this refers to a pre-made cons cell, not one made now
  p0 `(closure nil (x) ,@p3)
  (fn (x)
    (if (and (is cdr.p3 'nil)
             (is car.p3 p4)
             (is car.p4 'plus)
             (is cdr.p4 p7)
             (is (symbol-value 'plus) p8)
             (is cdr.p12 'nil)
             (is car.p12 p13)
             (is car.p13 'quasiquote)
             (is cdr.p13 p16)
             (is (symbol-value 'quasiquote) qq-object)
             (is car.p16 p17)
             (is car.p17 '+)
             (is cdr.p17 p20)
             (is car.p20 p21)
             (is car.p21 'unquote-splicing)
             (is cdr.p21 p23)
             (is car.p23 'args)
             (is cdr.p20 'nil)
             (is (symbol-value '+) +-function)
             (is car.p7 'x)
             (is cdr.p7 p27)
             (is car.p27 p28)
             (is car.p28 'plus)
             (is cdr.p28 p31)
             (is (symbol-value 'plus) p8)
             (is cdr.p12 'nil)
             (is car.p12 p13)
             (is car.p13 'quasiquote)
             (is cdr.p13 p16)
             (is (symbol-value 'quasiquote) qq-object)
             (is car.p16 p17)
             (is car.p17 '+)
             (is cdr.p17 p20)
             (is car.p20 p21)
             (is car.p21 'unquote-splicing)
             (is cdr.p21 p23)
             (is car.p23 'args)
             (is cdr.p20 'nil)
             (is (symbol-value '+) +-function)
             (is car.p31 '2)
             (is cdr.p31 p33)
             (is car.p33 '3)
             (is cdr.p33 'nil)
             (is cdr.p27 'nil))
        (+-function x '5)
        (let ev1 (obj x x)
          (apply-loop2 cdr.p3 ev1 p3)))))

;oh my god.  this is absolutely terrible.
;so horrible.
;oh my god.
;hooooooooooooooooooooooooooooooogh
;rceohucreohurceohurceohurcoehurceohucreohucreoh
;rceugeocrducoerdioecrudheontuheonuboeunboe

;however, I believe it is correct.
;now...

;as we saw, it is convenient to just add dicks to a list of funcs.
;also, all those checks should, um... hmm.
;exceptions...
;doing things during an exception...
;well. as we are pseudo-evaluating/compiling,
;everything we do should not raise an exception.
;(car 'nil) should become (let x 'nil (if acons.x (car x) ...
;ok, according to Arc, (car 'nil) = 'nil.
;but. (car 'a) should become (let x 'a (if acons.x (car x) <give up>)).

;so we can keep adding checked things to a list of checked things.
;and when we have a side effect or a call to an unknown thing,
;we can finish that list and do that thing, then start a new list
;of checked things, which (if violated) will point back to "right after
; we did that thing".
;... side effects are incredibly easy here.
;call to an unknown thing is more difficult.
;(f (complicated fucking expression))
;if f actually turns out to be a function most of the time,
;we don't want to compile (complicated fucking expression) repeatedly.
;(also f could be 'quote-object... eqv hard to a macro.)
;I guess we would have that one unjustified heuristic of "speculatively
; prepare to map-eval".
;or "inline the is-a-function branch of eval".
;or... yeah.
;--and this crap should be both harmlssly speculative and lazily
;incremental.  first compile to code that says "compile this shit
; and rebind the thing that points to this code to point to the new
; compiled code".
;(also anything that calls stubbed code should be some code that
; gets overwritten... mmm...)

;also, about this looping stuff.
;beta-expansion heuristics.
;they must come into play at some point.
;probably macros should always be beta-expanded.
;(perhaps not always)
;(this would make it possible for code with an infinite recursive macex
; to run, which I think is one thing compilers probably generally do
; not do)
;












